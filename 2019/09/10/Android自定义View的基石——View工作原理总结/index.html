<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="前言 View可以说是我们在Android开发中接触得最多的一个类了，虽然不属于四大组件，但是发挥的作用却一点都不亚于四大组件，页面中的各种控件、布局都直接或间接地继承自View，可以说View无处不在。因而了解View的工作原理能让我们更好地处理开发中的诸多问题，尤其是对于老生常谈的自定义View来说，View的工作原理更是必须要掌握的。">
<meta name="keywords" content="Android,View">
<meta property="og:type" content="article">
<meta property="og:title" content="Android自定义View的基石——View工作原理总结">
<meta property="og:url" content="http://yoursite.com/2019/09/10/Android自定义View的基石——View工作原理总结/index.html">
<meta property="og:site_name" content="快乐丸的博客">
<meta property="og:description" content="前言 View可以说是我们在Android开发中接触得最多的一个类了，虽然不属于四大组件，但是发挥的作用却一点都不亚于四大组件，页面中的各种控件、布局都直接或间接地继承自View，可以说View无处不在。因而了解View的工作原理能让我们更好地处理开发中的诸多问题，尤其是对于老生常谈的自定义View来说，View的工作原理更是必须要掌握的。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS0yZTRlZGVkMDE3MzM3NjU2LmpwZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NDQzNjUtNzYyNjEzMjVlNjU3NjM2MS5wbmc?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS1kZmI1MWQwOTE0MDM2YTU1LmpwZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS04MzExNDI5NWY0NDQyZDMyLmpwZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS1lZDEzNWZjZGUyZTcyNzNiLmpwZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS0zMGIyZDgwNTQwZjdjMmIyLmpwZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS0yMmU3NWY1ZDk2NzIyNGQ5LmpwZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS1iMjMwMmY0YWZkMWM1MWNhLmpwZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS0zMjQ5YzkxNjJkNjVjNGM0LmpwZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS0wOTAyYzEwY2ZiYzJlOGYxLmpwZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS1mOWUyYjNjNWZlODgwY2YxLmpwZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS1jY2NkMWQ5MzlkNzAzYzBhLmpwZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS1iNmIxNWFiNGZjY2U1NmUyLnBuZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS0yZDM1NDVmMjM3ZGYzNDIyLnBuZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS1hNTBiY2E5ZmZiNjgzMTNiLnBuZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS03YzMwN2YzMTIyMGZjMDNlLnBuZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS03YzMwN2YzMTIyMGZjMDNlLnBuZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS03YzMwN2YzMTIyMGZjMDNlLnBuZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS04YmFjNjJkODhhMzIzOGQ1LnBuZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS05YzQyM2YwNzc5MTMwODQ3LnBuZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS05ODZlZjA0Njc0MmU0ZWNlLnBuZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS04YmFjNjJkODhhMzIzOGQ1LnBuZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS05YzQyM2YwNzc5MTMwODQ3LnBuZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS05ODZlZjA0Njc0MmU0ZWNlLnBuZw?x-oss-process=image/format,png">
<meta property="og:updated_time" content="2019-09-16T08:12:47.729Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android自定义View的基石——View工作原理总结">
<meta name="twitter:description" content="前言 View可以说是我们在Android开发中接触得最多的一个类了，虽然不属于四大组件，但是发挥的作用却一点都不亚于四大组件，页面中的各种控件、布局都直接或间接地继承自View，可以说View无处不在。因而了解View的工作原理能让我们更好地处理开发中的诸多问题，尤其是对于老生常谈的自定义View来说，View的工作原理更是必须要掌握的。">
<meta name="twitter:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS0yZTRlZGVkMDE3MzM3NjU2LmpwZw?x-oss-process=image/format,png">
  <link rel="canonical" href="http://yoursite.com/2019/09/10/Android自定义View的基石——View工作原理总结/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Android自定义View的基石——View工作原理总结 | 快乐丸的博客</title>
  <meta name="generator" content="Hexo 3.9.0">
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>
	
	<a href="https://github.com/StephenZKCurry" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">快乐丸的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Keep Learning</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-wrapper">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    

  <article class="post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/10/Android自定义View的基石——View工作原理总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Stephen Curry">
      <meta itemprop="description" content="I can do all things">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="快乐丸的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Android自定义View的基石——View工作原理总结

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-09-10 13:44:55" itemprop="dateCreated datePublished" datetime="2019-09-10T13:44:55+08:00">2019-09-10</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-16 16:12:47" itemprop="dateModified" datetime="2019-09-16T16:12:47+08:00">2019-09-16</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a></span>

                
                
              
            </span>
          

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p><strong>前言</strong></p>
<p>View可以说是我们在Android开发中接触得最多的一个类了，虽然不属于四大组件，但是发挥的作用却一点都不亚于四大组件，页面中的各种控件、布局都直接或间接地继承自View，可以说View无处不在。因而了解View的工作原理能让我们更好地处理开发中的诸多问题，尤其是对于老生常谈的自定义View来说，View的工作原理更是必须要掌握的。</p>
</blockquote>
<a id="more"></a>

<p>在进入正文之前还是要强调一下，<strong>本文的分析基于Android 9.0（API Level 28）的源码</strong>，不同版本的源码可能会有不同，但是基本思路不会变化太多，可以进行参考。此外，本文的篇幅较长，可以根据目录选择章节来查看。</p>
<h2 id="几个相关类"><a href="#几个相关类" class="headerlink" title="几个相关类"></a>几个相关类</h2><p>在介绍View的工作原理之前首先要介绍几个相关的类，它们在View的工作流程中扮演了重要的角色，了解它们能让我们对于View的工作原理有一个更全面的认识。</p>
<h3 id="Window和WindowManager"><a href="#Window和WindowManager" class="headerlink" title="Window和WindowManager"></a>Window和WindowManager</h3><p><strong>Window</strong>顾名思义是表示一个窗口，虽然我们在开发中可能很少直接去操作Window，我目前接触过的也仅仅是给Window添加一些Flag的操作，但是Window在Android的视图体系中其实是很重要的一环，它可以说是所有视图的<strong>承载器</strong>，我们最熟悉的Activity的视图实际上也是附加在Window上，通过Window来管理的。Window是一个抽象类，它只有一个实现类<strong>PhoneWindow</strong>，因此我们在分析源码时直接看PhoneWindow就可以了。<br><strong>WindowManager</strong>可以译为窗口管理者，是外界访问Window的入口，我们可以通过WindowManager来操作Window。WindowManager是一个接口，它的实现类是<strong>WindowManagerImpl</strong>。</p>
<h3 id="DecorView"><a href="#DecorView" class="headerlink" title="DecorView"></a>DecorView</h3><p><strong>DecorView</strong>是最顶层的View，是整个视图的根节点，继承自FrameLayout，因此它也是一个ViewGroup。下面以一张图来展示可能更直观一些。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS0yZTRlZGVkMDE3MzM3NjU2LmpwZw?x-oss-process=image/format,png" alt><br>DecorView下包含一个竖直方向的LinearLayout，它的内部根据页面主题的不同可能会有所不同，但是一定会包含一个子View，它的id为<strong>android.R.id.content</strong>，是一个FrameLayout，我们调用<code>setContentView()</code>设置的布局就是添加到了这个contentView中。</p>
<h3 id="ViewRoot"><a href="#ViewRoot" class="headerlink" title="ViewRoot"></a>ViewRoot</h3><p>ViewRoot对应于<strong>ViewRootImpl</strong>，是连接WindowManager和DecorView的纽带，View的measure、layout和draw流程都是通过ViewRootImpl完成的。</p>
<h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><p>这里将以下几个流程称作View工作流程的准备阶段，可能不是很确切，主要还是为了和我们熟知的measure、layout、draw三大流程区分开，这一阶段完成的工作是Window和DecorView的创建以及对三大流程的调用。</p>
<h3 id="Window的创建"><a href="#Window的创建" class="headerlink" title="Window的创建"></a>Window的创建</h3><p>Window的创建时机是在<strong>ActivityThread</strong>的<code>performLaunchActivity()</code>方法中，在之前Activity的启动流程中也分析过该方法，我们再来简单回顾一下：<br><strong>ActivityThread的performLaunchActivity方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">    <span class="comment">// 1.创建Activity对象</span></span><br><span class="line">    activity = mInstrumentation.newActivity(</span><br><span class="line">            cl, component.getClassName(), r.intent);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 2.创建Application对象，如果已经创建则不会重复创建</span></span><br><span class="line">    Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Window window = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.mPendingRemoveWindow != <span class="keyword">null</span> &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class="line">            window = r.mPendingRemoveWindow;</span><br><span class="line">            r.mPendingRemoveWindow = <span class="keyword">null</span>;</span><br><span class="line">            r.mPendingRemoveWindowManager = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        appContext.setOuterContext(activity);</span><br><span class="line">      	<span class="comment">// 3.创建PhoneWindow</span></span><br><span class="line">        activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      	<span class="comment">// 4.调用onCreate()方法</span></span><br><span class="line">        <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">            mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        r.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法内部会依次创建Activity对象和Application对象，最后通过Instrumentation对象调用Activity的<code>onCreate()</code>方法，这些都不是我们这里要关注的，我们只需要分析Activity的<code>attach()</code>方法。<br><strong>Activity的attach方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">                  Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">                  CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">                  NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">                  Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">                  Window window, ActivityConfigCallback activityConfigCallback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建PhoneWindow</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">  	<span class="comment">// 设置回调</span></span><br><span class="line">  	mWindow.setWindowControllerCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	</span><br><span class="line">  	<span class="comment">// 设置WindowManager</span></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现PhoneWindow对象就是在<code>attach()</code>方法中创建的，之后会为PhoneWindow设置相关回调并创建WindowManager对象（实际上是WindowManagerImpl对象）。</p>
<h3 id="DecorView的创建"><a href="#DecorView的创建" class="headerlink" title="DecorView的创建"></a>DecorView的创建</h3><p>在Activity的<code>onCreate()</code>方法中我们会调用<code>setContentView()</code>来设置页面的布局，DecorView的创建就要从该方法来分析。<br><strong>Activity的setContentView方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getWindow()</code>方法获取到的就是上面创建好的PhoneWindow对象，我们接着来看PhoneWindow的<code>setContentView()</code>方法：<br><strong>PhoneWindow的setContentView方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先会判断mContentParent是否为空，如果为空就调用<code>installDecor()</code>方法，否则调用<code>removeAllViews()</code>方法移除mContentParent的所有子View。那么这个mContentParent是什么呢，它是一个ViewGroup，我们通过名称可能能够猜到它就是我们页面所展示的内容。全局搜索了一下mContentParent的赋值时机，发现只有在<code>installDecor()</code>方法中才会对其赋值，因此这里mContentParent为空，我们来看看<code>installDecor()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mForceDecorInstall = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDecor = generateDecor(-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mDecor.setWindow(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DecorView <span class="title">generateDecor</span><span class="params">(<span class="keyword">int</span> featureId)</span> </span>&#123;</span><br><span class="line">    Context context;</span><br><span class="line">    <span class="keyword">if</span> (mUseDecorContext) &#123;</span><br><span class="line">        Context applicationContext = getContext().getApplicationContext();</span><br><span class="line">        <span class="keyword">if</span> (applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">            context = getContext();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            context = <span class="keyword">new</span> DecorContext(applicationContext, getContext());</span><br><span class="line">            <span class="keyword">if</span> (mTheme != -<span class="number">1</span>) &#123;</span><br><span class="line">                context.setTheme(mTheme);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        context = getContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecorView(context, featureId, <span class="keyword">this</span>, getAttributes());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">    TypedArray a = getWindowStyle();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">int</span> layoutResource;</span><br><span class="line">    <span class="comment">// 根据Features（通过requestFeature()方法添加，可以看做是Window的主题样式）设置相应的布局</span></span><br><span class="line">    <span class="comment">// 伪代码</span></span><br><span class="line">    <span class="keyword">if</span> () &#123;</span><br><span class="line">        layoutResource =R.layout.xx1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> () &#123;</span><br><span class="line">        layoutResource =R.layout.xx2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        layoutResource =R.layout.xx;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 为DecorView加载布局</span></span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line"></span><br><span class="line">    ViewGroup contentParent = (ViewGroup) findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> contentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>installDecor()</code>方法主要做的事有两件：调用<code>generateDecor()</code>方法创建DecorView，将返回值赋给mDecor；调用<code>generateLayout()</code>方法创建一个ViewGroup，赋值给mContentParent。这里的<code>generateDecor()</code>和<code>generateLayout()</code>方法都省略了大量代码，只保留了最核心的部分。<br>创建好了DecorView和mContentParent之后，我们回到PhoneWindow的<code>setContentView()</code>方法，可以发现这之后调用了<code>mLayoutInflater.inflate(layoutResID, mContentParent)</code>，<code>inflate()</code>方法的作用我们都很熟悉了，就是根据我们传入的布局文件构建出View树，这里调用的是两个参数的方法，因此会将创建好的View树添加到mContentParent中。如果不是很清楚<code>inflate()</code>方法几个参数的意义可以查阅网上的相关文章，或者参考我之前写过的一篇文章<a href="https://github.com/StephenZKCurry/Android-Study-Notes/blob/master/Android/LayoutInflate%E7%9A%84%E4%BD%BF%E7%94%A8.md" target="_blank" rel="noopener">LayoutInflate的使用</a>，这里我就不具体讲了。现在我们就清楚了mContentParent是什么了吧，它是我们<code>setContentView()</code>方法中指定布局的父View，指定的布局会作为一个子View添加到mContentParent中。<br>我一开始分析时有一个疑问，mContentParent是何时与DecorView产生联系的呢，分析到这里好像并没有看到诸如<code>mDecor.addView()</code>之类的代码，我们回到<code>generateLayout()</code>方法中，方法内部调用了<code>findViewById()</code>方法获取到contentParent，并将其赋给mContentParent，而这个id为content，是DecorView中的一个子View，是一个Framelayout，因此contentParent就是DecorView中的这个子View，mContentParent自然也表示这个子View。<code>generateLayout()</code>方法中会根据Window的主题样式为DecorView加载相应的布局，我们就以其中一个<strong>R.layout.screen_simple</strong>为例，看看它的布局层级关系：<br><strong>screen_simple.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ViewStub</span> <span class="attr">android:id</span>=<span class="string">"@+id/action_mode_bar_stub"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:inflatedId</span>=<span class="string">"@+id/action_mode_bar"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout</span>=<span class="string">"@layout/action_mode_bar"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:theme</span>=<span class="string">"?attr/actionBarTheme"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:id</span>=<span class="string">"@android:id/content"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foregroundInsidePadding</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foregroundGravity</span>=<span class="string">"fill_horizontal|top"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foreground</span>=<span class="string">"?android:attr/windowContentOverlay"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到最外层是一个LinearLayout，内部有两个子View，一个是<strong>ViewStub</strong>，它的id为<strong>action_mode_bar_stub</strong>，从名称上大概可以猜出它是页面的标题栏，会根据主题的不同来选择是否加载；另一个子View是id为<strong>content</strong>的<strong>FrameLayout</strong>，也就是上面分析中<code>findViewById()</code>方法获取到的contentParent，因此mContentParent就是这个FrameLayout。<br>看到这里，我们对于整个页面的层级关系就很清楚了，最外层是一个DecorView，它的内部有一个LinearLayout，LinearLayout中有一个FrameLayout，我们在<code>setContentView()</code>中指定的布局文件会被添加到这个FrameLayout中，当然实际上根据主题样式的不同可能会更复杂一些，这里只是说明最简单的一种情况。<br>值得一提的是，<strong>AppCompatActivity</strong>中的<code>setContentView()</code>方法和Activity的有所不同，简单分析一下。<br><strong>AppCompatActivity的setContentView方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    getDelegate().setContentView(layoutResID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getDelegate()</code>获取到的是一个代理对象，类型为<strong>AppCompatDelegateImpl</strong>（前几个版本的源码中这里会根据SDK版本不同返回不同的对象如<strong>AppCompatDelegateImplN</strong>、<strong>AppCompatDelegateImplV23</strong>等，后面的分析是差不多的），之后调用了AppCompatDelegateImpl的<code>setContentView()</code>方法。<br><strong>AppCompatDelegateImpl的setContentView方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> resId)</span> </span>&#123;</span><br><span class="line">    ensureSubDecor();</span><br><span class="line">    ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content);</span><br><span class="line">    contentParent.removeAllViews();</span><br><span class="line">    LayoutInflater.from(mContext).inflate(resId, contentParent);</span><br><span class="line">    mOriginalWindowCallback.onContentChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法内部首先调用了<code>ensureSubDecor()</code>方法，将返回值赋值给mSubDecor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureSubDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSubDecorInstalled) &#123;</span><br><span class="line">        mSubDecor = createSubDecor();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ViewGroup <span class="title">createSubDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TypedArray a = mContext.obtainStyledAttributes(R.styleable.AppCompatTheme);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 分析1</span></span><br><span class="line">    mWindow.getDecorView();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> LayoutInflater inflater = LayoutInflater.from(mContext);</span><br><span class="line">    ViewGroup subDecor = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据主题为subDecor加载布局</span></span><br><span class="line">    <span class="comment">// 伪代码</span></span><br><span class="line">    <span class="keyword">if</span> () &#123;</span><br><span class="line">        subDecor = (ViewGroup) LayoutInflater.from(themedContext)</span><br><span class="line">                .inflate(R.layout.xx, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  	<span class="comment">// 分析2</span></span><br><span class="line">    <span class="keyword">final</span> ContentFrameLayout contentView = (ContentFrameLayout) subDecor.findViewById(</span><br><span class="line">            R.id.action_bar_activity_content);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ViewGroup windowContentView = (ViewGroup) mWindow.findViewById(android.R.id.content);</span><br><span class="line">    <span class="keyword">if</span> (windowContentView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将windowContentView的子View移除并添加到contentView中</span></span><br><span class="line">        <span class="keyword">while</span> (windowContentView.getChildCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = windowContentView.getChildAt(<span class="number">0</span>);</span><br><span class="line">            windowContentView.removeViewAt(<span class="number">0</span>);</span><br><span class="line">            contentView.addView(child);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        windowContentView.setId(View.NO_ID);</span><br><span class="line">        contentView.setId(android.R.id.content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  	<span class="comment">// 分析3</span></span><br><span class="line">    mWindow.setContentView(subDecor);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> subDecor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ensureSubDecor()</code>方法内部调用了<code>createSubDecor()</code>方法，我们具体分析一下该方法。<br><strong>分析1、mWindow.getDecorView()</strong><br>mWindow的类型为PhoneWindow，通过查看PhoneWindow的<code>getDecorView()</code>方法我们可以发现，由于此时mDecor并未被赋值过，因此会调用此前分析过的<code>installDecor()</code>方法，创建DecorView和mContentParent。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">getDecorView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span> || mForceDecorInstall) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mDecor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后和<code>generateLayout()</code>方法很类似，通过判断主题样式创建出subDecor，加载不同的布局文件。<br><strong>分析2、“偷梁换柱”</strong><br>这里的逻辑还是很巧妙的，涉及到了两个View，contentView是subDecor中id为<strong>action_bar_activity_content</strong>的子View，类型为ContentFrameLayout；另一个windowContentView的id为<strong>android.R.id.content</strong>，没错，就是此前分析过的那个FrameLayout。之后的操作是将windowContentView的子View移除，添加到contentView中，并将windowContentView的id设置为View.NO_ID，将contentView的id设置为android.R.id.content，看上去很像是两个View之间的互换，因此我把这个操作称为“偷梁换柱”。<br><strong>分析3、mWindow.setContentView(subDecor)</strong><br>这里调用了PhoneWindow的<code>setContentView()</code>方法，将subDecor添加到了mContentParent中，这里的mContentParent其实就是上面的windowContentView，此时它的id已经变成了View.NO_ID。<br>这时我们再回到AppCompatDelegateImpl的<code>setContentView()</code>方法，之后就是根据我们指定的布局文件构建出View树并添加到id为<strong>android.R.id.content</strong>的ViewGroup中，即上面的ContentFrameLayout。<br>我的表述不是很清楚，大家可能有些懵了，这都是什么乱七八糟的，我最后总结一下，其实大体上的流程和Activity的<code>setContentView()</code>方法还是很类似的，不同之处就是在Activity中，我们指定布局文件对应的View树会被添加到FrameLayout中，而对于AppCompatActivity，View树会被添加到一个ContentFrameLayout中，它们的id均为<strong>android.R.id.content</strong>，层级关系如下，ContentFrameLayout的直接父View是mSubDecor所加载布局的根布局，对应不同的主题样式可能不同，这个根布局的父View就是FrameLayout，因此可以看做就是多嵌套了几层View。<br>其实这里我就不明白了，我们的Activity都是继承自AppCompatActivity，那么相比于继承自Activity，我们的布局层级是要复杂一些的，大家都知道Android开发中是要避免过多的布局层级嵌套的，那么AppCompatActivity这样做的目的是什么呢？鉴于个人能力和认识都还很浅显，想不明白为什么要这样设计，欢迎大佬们提出自己的见解。</p>
<h3 id="三大流程的调用"><a href="#三大流程的调用" class="headerlink" title="三大流程的调用"></a>三大流程的调用</h3><p>上面的两个流程中已经完成了PhoneWindow和DecorView的创建，那么大名鼎鼎的View绘制三大流程又是从何时开始的呢，就是ActivityThread的<code>handleResumeActivity()</code> 方法，该方法在分析Activity的启动流程时也分析过，<code>onResume()</code>回调方法就是经由该方法调用的。<br><strong>ActivityThread的handleResumeActivity方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest, <span class="keyword">boolean</span> isForward,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 方法内部调用Activity的onResume()方法</span></span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">        r.window = r.activity.getWindow();</span><br><span class="line">        <span class="comment">// 获取DecorView</span></span><br><span class="line">        View decor = r.window.getDecorView();</span><br><span class="line">        <span class="comment">// 将DecorView设置为不可见</span></span><br><span class="line">        decor.setVisibility(View.INVISIBLE);</span><br><span class="line">        <span class="comment">// 获取WindowManager</span></span><br><span class="line">        ViewManager wm = a.getWindowManager();</span><br><span class="line">        WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">        <span class="comment">// 为Activity的mDecor对象赋值</span></span><br><span class="line">        a.mDecor = decor;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 将DecorView添加到Window中</span></span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a.onWindowAttributesChanged(l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != <span class="keyword">null</span> &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">            <span class="comment">// 将DecorView设置为可见</span></span><br><span class="line">            r.activity.makeVisible();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要做了两件事：调用<code>performResumeActivity()</code>方法，进而调用Activity的生命周期回调<code>onResume()</code>；获取此前创建好的PhoneWindow、DecorView以及WindowManager对象，调用WindowManager的<code>addView()</code>方法将DecorView添加到Window中。前面也说过，WindowManager的实现类是WindowManagerImpl，因此我们来具体看一下WindowManagerImpl的<code>addView()</code>方法都做了些什么。<br><strong>WindowManagerImpl的addView方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法内部调用了mGlobal的<code>addView()</code>方法，mGlobal的类型为WindowManagerGlobal，我们接着看：<br><strong>WindowManagerGlobal的addView方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">                    Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 创建ViewRootImpl对象</span></span><br><span class="line">    root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">  </span><br><span class="line">    view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">    mViews.add(view);</span><br><span class="line">    mRoots.add(root);</span><br><span class="line">    mParams.add(wparams);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">// 核心代码</span></span><br><span class="line">        root.setView(view, wparams, panelParentView);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// BadTokenException or InvalidDisplayException, clean up.</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            removeViewLocked(index, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>addView()</code>方法内部首先会创建出ViewRootImpl对象，将要添加的View（即DecorView）、ViewRootImpl和布局参数添加到列表中，最后调用ViewRootImpl的<code>setView()</code>方法，我们来看一下这个方法。<br><strong>ViewRootImpl的setView方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mView = view;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            requestLayout();</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>setView()</code>方法内部调用了<code>requestLayout()</code>方法，这个方法可能大家在自定义View时用到过，用于刷新视图，不过需要注意的是，我们在自定义View中调用的<code>requestLayout()</code>方法是在View中定义的，和ViewRootImpl中的逻辑是不一样的。接下来我们就来看看ViewRootImpl的<code>requestLayout()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法内部又调用了<code>scheduleTraversals()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">      	<span class="comment">// 开启同步屏障机制</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">      	<span class="comment">// 利用Handler发送一条异步消息</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>scheduleTraversals()</code>方法内部首先执行了<code>mHandler.getLooper().getQueue().postSyncBarrier()</code>，这行代码的作用是开启Handler的同步屏障机制，关于Handler的同步屏障机制，我这里简单解释一下（因为我了解得也不是很透彻o(╥﹏╥)o），我们都知道Handler处理的消息是放到一个消息队列中的，消息默认情况下都是同步的，如果需要发送异步消息需要使用代码来声明，同步屏障机制就使得Looper在从消息队列中获取消息时，只获取异步消息并进行处理。我可能解释得不太好，如果想深入了解一下Handler的同步屏障机制可以自行查找资料，这里推荐一下鸿洋大神WanAndroid上的每日一问<a href="https://www.wanandroid.com/wenda/show/8710" target="_blank" rel="noopener">Handler应该是大家再熟悉不过的类了，那么其中有个同步屏障机制，你了解多少呢？</a>。开启了同步屏障后，调用了mChoreographer的<code>postCallback()</code>方法，该方法内部就是利用了Handler，发送了一个Runable对象，如果跟踪源码的话可以发现最后会把Runable封装为一个Message，并将Message设置为异步消息，我就不展示了。清楚了<code>postCallback()</code>方法的原理后，我们就知道了需要分析mTraversalRunnable对象，它是一个Runable对象，类型为<strong>TraversalRunnable</strong> ，在<code>run()</code>方法中调用了<code>doTraversal()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于开启了同步屏障，因此当前线程（主线程）的Looper会优先获取异步消息，即直接执行<code>doTraversal()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">      	<span class="comment">// 关闭同步屏障</span></span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        performTraversals();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>doTraversal()</code>方法内部首先会关闭同步屏障机制，否则主线程的同步消息就永远无法被处理了，然后调用了<code>performTraversals()</code>方法，我们来看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 调用performMeasure()方法开始measure流程</span></span><br><span class="line">    measureHierarchy(host, lp, res,</span><br><span class="line">            desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 开始layout流程</span></span><br><span class="line">    performLayout(lp, mWidth, mHeight);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 开始draw流程</span></span><br><span class="line">    performDraw();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里省略了大量代码，可以看出，在<code>performTraversals()</code>方法内会依次调用<code>measureHierarchy()</code> 、<code>performLayout()</code>、<code>performDraw()</code>，进而开始View的三大流程。<br>分析到这里，View的绘制准备阶段就算完成了，最后再回顾一下，主要分为三个阶段：</p>
<ul>
<li>Activity的<code>onCreate()</code>方法调用之前，创建Window（PhoneWindow）</li>
<li>Activity的<code>onCreate()</code>方法中调用<code>setContentView()</code>方法，创建DecorView和contentView（页面内容根布局），将指定的布局文件加载到contentView中</li>
<li>Activity的<code>onResume()</code>方法调用之后，将DecorView添加到Window中，之后依次开始View的measure、layout和draw流程</li>
</ul>
<p>从上面几个流程的先后顺序我们就能清楚为什么在<code>onResume()</code>方法中或者<code>onResume()</code>方法之前获取不到View的宽高，就是因为此时View还未执行measure和layout流程。</p>
<h2 id="measure阶段"><a href="#measure阶段" class="headerlink" title="measure阶段"></a>measure阶段</h2><p>到这里算是正式进入到了View的三大流程，首先要分析的是measure流程。在分析View的measure流程之前，我们首先要介绍两个相关的类：<strong>MeasureSpec</strong>和<strong>LayoutParams</strong>。</p>
<h3 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h3><h4 id="MeasureSpec简介"><a href="#MeasureSpec简介" class="headerlink" title="MeasureSpec简介"></a>MeasureSpec简介</h4><p>关于<strong>MeasureSpec</strong>大家可能都很熟悉了，它是由一个32位int值表示的，高2位表示<strong>SpecMode</strong>，即测量模式，低30位表示<strong>SpecSize</strong>，即测量尺寸大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MeasureSpec</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	</span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 三种测量模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据测量尺寸和测量模式生成MeasureSpec</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(@IntRange(from = <span class="number">0</span>, to = (<span class="number">1</span> &lt;&lt; MeasureSpec.MODE_SHIFT)</span> - 1) <span class="keyword">int</span> size,</span></span><br><span class="line"><span class="function">                                      @MeasureSpecMode <span class="keyword">int</span> mode) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</span><br><span class="line">            <span class="keyword">return</span> size + mode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得测量模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@MeasureSpecMode</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//noinspection ResourceType</span></span><br><span class="line">        <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得测量尺寸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过调用<code>getMode()</code>和<code>getSize()</code>方法获取到测量模式和测量尺寸，方法内部就是通过简单的位运算保留指定位数上的数值。不由得称赞Android系统开发人员的设计巧妙，将两个值封装成了一个变量，可以通过位运算获取相应数值，减少了多余对象的内存分配，其实Android源码中很多地方都有类似设计（比如MotionEvent），这里就不多提啦。<br>MeasureSpec内部定义了三种测量模式：</p>
<blockquote>
<p><strong>UNSPECIFIED</strong>：父View不会限制子View的大小，一般用于系统内部，开发中使用很少<br><strong>EXACTLY</strong>：父View能够确定子View的大小，对应两种情况：<strong>精确尺寸（dp或px）</strong>和<strong>match_parent</strong><br><strong>AT_MOST</strong>：子View的大小不能超过父View尺寸，具体尺寸需要由子View自身来确定，对应<strong>wrap_content</strong></p>
</blockquote>
<p>虽然我们在开发中用到<strong>UNSPECIFIED</strong>模式的情况不多，但是了解一下还是有必要的，我在后面会单独介绍一下这个模式的应用。</p>
<h4 id="如何确定MeasureSpec的值"><a href="#如何确定MeasureSpec的值" class="headerlink" title="如何确定MeasureSpec的值"></a>如何确定MeasureSpec的值</h4><p>MeasureSpec的值是由<strong>View自身的LayoutParams</strong>和<strong>父View的MeasureSpec</strong>共同确定的。对于特定的View来说，它的MeasureSpec是通过父View（即ViewGroup）的<code>getChildMeasureSpec()</code>方法得到的。<br><strong>ViewGroup的getChildMeasureSpec方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得子View的MeasureSpec</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> spec           父View的MeasureSpec</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> padding        父View的padding</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> childDimension 子View的LayoutParams指定的宽/高</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得父View的测量模式和测量尺寸</span></span><br><span class="line">  	<span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</span><br><span class="line">	</span><br><span class="line">  	<span class="comment">// 父View实际可用大小</span></span><br><span class="line">    <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> resultMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">        <span class="comment">// 父View的测量模式为EXACTLY，即match_parent或精确尺寸</span></span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              	<span class="comment">// 子View的LayoutParams指定为精确的值</span></span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">              	<span class="comment">// 子View的LayoutParams指定为MATCH_PARENT</span></span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">              	<span class="comment">// 子View的LayoutParams指定为WRAP_CONTENT</span></span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父View的测量模式为AT_MOST，即wrap_content</span></span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父View的测量模式为UNSPECIFIED</span></span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">                resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">                resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getChildMeasureSpec()</code>方法也验证了子View的MeasureSpec是由父View的MeasureSpec和子View的LayoutParams共同确定的。上面的判断可能有些复杂，不过别担心。已经有很多大佬总结出了表格，看起来更加直观一些，下图摘自<a href="https://www.jianshu.com/p/1dab927b2f36" target="_blank" rel="noopener">Carson_Ho大佬的博客</a>，表中的childSize表示子View的LayoutParams指定的大小，parentSize表示父View可用空间的大小。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NDQzNjUtNzYyNjEzMjVlNjU3NjM2MS5wbmc?x-oss-process=image/format,png" alt><br>我们可以先不去看最后一列<strong>UNSPECIFIED</strong>的情况，单看前两列可以找出一定的规律：</p>
<ul>
<li>当子View的LayoutParams指定为精确数值时，不管父View的测量模式是什么，子View的测量模式均为<strong>EXACTLY</strong>，测量尺寸为LayoutParams指定的值</li>
<li>当子View的LayoutParams指定为match_parent时，子View的测量模式取决于父View，即如果父View的测量模式为<strong>EXACTLY</strong>，那么子View的测量模式为<strong>EXACTLY</strong>；如果父View的测量模式为<strong>AT_MOST</strong>，那么子View的测量模式为<strong>AT_MOST</strong>，子View的测量尺寸均为父View可用空间大小</li>
<li>当子View的LayoutParams指定为wrap_content时，不管父View的测量模式是什么，子View的测量模式均为<strong>AT_MOST</strong>，测量尺寸为父View可用空间大小</li>
</ul>
<p>普通View的MeasureSpec是如何获取的我们已经清楚了，那么对于DecorView来说，它是没有父View的，它的MeasureSpec是如何得到的呢？我们在上一节分析到ViewRootImpl的<code>performTraversals()</code>方法时，介绍到方法内部调用了<code>measureHierarchy()</code>方法，进而调用<code>performMeasure()</code>方法开始View的measure流程，现在我们就来具体看一下<code>measureHierarchy()</code>方法。<br><strong>ViewRootImpl的measureHierarchy方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">measureHierarchy</span><span class="params">(<span class="keyword">final</span> View host, <span class="keyword">final</span> WindowManager.LayoutParams lp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">final</span> Resources res, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowWidth, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childWidthMeasureSpec;</span><br><span class="line">    <span class="keyword">int</span> childHeightMeasureSpec;</span><br><span class="line">  	<span class="keyword">boolean</span> windowSizeMayChange = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	</span><br><span class="line">    childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);</span><br><span class="line">    childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</span><br><span class="line">    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> windowSizeMayChange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出这里调用<code>getRootMeasureSpec()</code>方法获取到childWidthMeasureSpec和childHeightMeasureSpec，之后调用<code>performMeasure()</code>方法，方法内部又调用了mView的<code>measure()</code>方法，这个mView是什么呢，我全文检索了一下mView的赋值时机，发现它是在<code>setView()</code>方法中被赋值的，还记得<code>setView()</code>方法是什么时候调用的吗，就是在<code>handleResumeActivity()</code>方法中调用<code>wm.addView(decor,l)</code>这行代码之后被调用的，因此这里的mView就是传过来的DecorView，调用<code>measure()</code>方法就开始了对DecorView的测量流程。现在就要关注childWidthMeasureSpec和childHeightMeasureSpec了，这两个值就是DecorView的MeasureSpec，我们来看一下获取到这两个值的<code>getRootMeasureSpec()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> measureSpec;</span><br><span class="line">    <span class="keyword">switch</span> (rootDimension) &#123;</span><br><span class="line">        <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</span><br><span class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> measureSpec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑还是比较简单的，参数windowSize传递过来的值是desiredWindowWidth和desiredWindowHeight，通过查看源码可以发现这两个值表示屏幕的宽高尺寸，因此我们可以得出以下结论：</p>
<ul>
<li>DecorView的LayoutParams指定为<strong>MATCH_PARENT</strong>时，它的测量模式为<strong>EXACTLY</strong>，测量尺寸为屏幕尺寸</li>
<li>DecorView的LayoutParams指定为<strong>WRAP_CONTENT</strong>时，它的测量模式为<strong>WRAP_CONTENT</strong>，测量尺寸为屏幕尺寸</li>
</ul>
<p>可以看出，DecorView作为最顶层的View，它的MeasureSpec只取决于自己的LayoutParams参数。</p>
<h3 id="LayoutParams"><a href="#LayoutParams" class="headerlink" title="LayoutParams"></a>LayoutParams</h3><h4 id="LayoutParams简介"><a href="#LayoutParams简介" class="headerlink" title="LayoutParams简介"></a>LayoutParams简介</h4><p><strong>LayoutParams</strong>这个类在开发中还是很常见的，顾名思义就是布局参数，View中定义了一个LayoutParams类型的成员变量，它的作用就是确定View的宽高，我们平时在xml布局文件中指定的<strong>layout_width</strong>和<strong>layout_height</strong>属性就是用于生成LayoutParams。需要注意的是，这两个属性的前面都带上layout前缀，而不是直接使用<strong>width</strong>和<strong>height</strong>来命名，因此我们要清楚它们的值并不是View的宽高，也可以说它们并不属于View自身的属性。<br>LayoutParams是ViewGroup中的一个内部类，我们看一下它的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutParams</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FILL_PARENT = -<span class="number">1</span>; <span class="comment">// 已被MATCH_PARENT取代</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MATCH_PARENT = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRAP_CONTENT = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ViewDebug</span>.ExportedProperty(category = <span class="string">"layout"</span>, mapping = &#123;</span><br><span class="line">            <span class="meta">@ViewDebug</span>.IntToString(from = MATCH_PARENT, to = <span class="string">"MATCH_PARENT"</span>),</span><br><span class="line">            <span class="meta">@ViewDebug</span>.IntToString(from = WRAP_CONTENT, to = <span class="string">"WRAP_CONTENT"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ViewDebug</span>.ExportedProperty(category = <span class="string">"layout"</span>, mapping = &#123;</span><br><span class="line">            <span class="meta">@ViewDebug</span>.IntToString(from = MATCH_PARENT, to = <span class="string">"MATCH_PARENT"</span>),</span><br><span class="line">            <span class="meta">@ViewDebug</span>.IntToString(from = WRAP_CONTENT, to = <span class="string">"WRAP_CONTENT"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LayoutAnimationController.AnimationParameters layoutAnimationParameters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * xml文件中指定的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(Context c, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        TypedArray a = c.obtainStyledAttributes(attrs, R.styleable.ViewGroup_Layout);</span><br><span class="line">        setBaseAttributes(a,</span><br><span class="line">                R.styleable.ViewGroup_Layout_layout_width,</span><br><span class="line">                R.styleable.ViewGroup_Layout_layout_height);</span><br><span class="line">        a.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 手动指定宽高属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定LayoutParams</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">(LayoutParams source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.width = source.width;</span><br><span class="line">        <span class="keyword">this</span>.height = source.height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LayoutParams() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LayoutParams中定义了几个重载构造函数，分别用于xml文件中指定宽高、手动指定宽高等场景。每个ViewGroup的子类（直接或间接继承）都有对应的LayoutParams类，比如<strong>LinearLayout.LayoutParams</strong>，在各自的LayoutParams中可以定义相应的布局参数属性。因此不止<strong>layout_width</strong>和<strong>layout_height</strong>这两个属性，其他以layout开头的属性（比如<strong>layout_weight</strong>、<strong>layout_margin</strong>等等）也都和LayoutParams相关。</p>
<h4 id="View的LayoutParams属性是何时设置的"><a href="#View的LayoutParams属性是何时设置的" class="headerlink" title="View的LayoutParams属性是何时设置的"></a>View的LayoutParams属性是何时设置的</h4><p>了解了LayoutParams的定义后，接下来需要弄清楚View的LayoutParams属性是何时设置的，我们知道在ViewGroup中添加子View的方式有两种：xml文件中添加和代码中添加，我们分别来看一下这两种情况。</p>
<ul>
<li><strong>xml文件中添加View</strong></li>
</ul>
<p>在<code>setContentView()</code>方法的分析中我们知道xml文件中添加的View最终是通过<strong>LayoutInflater</strong>的<code>inflate()</code>方法来解析的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(XmlPullParser parser, @Nullable ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mConstructorArgs) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        View result = root;</span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line">        <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</span><br><span class="line">                type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">final</span> String name = parser.getName();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">final</span> View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line">        ViewGroup.LayoutParams params = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// 调用generateLayoutParams()方法生成LayoutParams</span></span><br><span class="line">            params = root.generateLayoutParams(attrs);</span><br><span class="line">            <span class="keyword">if</span> (!attachToRoot) &#123;</span><br><span class="line">                temp.setLayoutParams(params);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rInflateChildren(parser, temp, attrs, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; attachToRoot) &#123;</span><br><span class="line">            root.addView(temp, params);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || !attachToRoot) &#123;</span><br><span class="line">            result = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>inflate()</code>方法中有一行代码是<code>params = root.generateLayoutParams(attrs);</code>，<code>generateLayoutParams()</code>方法的作用就是就是根据xml指定的属性构造出LayoutParams对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LayoutParams <span class="title">generateLayoutParams</span><span class="params">(AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LayoutParams(getContext(), attrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造出LayoutParams对象后根据参数<strong>attachToRoot</strong>的值有两种处理逻辑：</p>
<ul>
<li><p>如果<strong>attachToRoot</strong>为true，则会调用<code>addView()</code>方法并传入构造好的LayoutParams对象，<code>addView()</code>方法内部会将LayoutParams对象设置给View，详细代码后面会展示，这里先这样记住就好</p>
</li>
<li><p>如果<strong>attachToRoot</strong>为false，则会调用View的<code>setLayoutParams()</code>方法直接将构造好的LayoutParams对象设置给View</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLayoutParams</span><span class="params">(ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (params == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Layout parameters cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 给mLayoutParams变量赋值</span></span><br><span class="line">    mLayoutParams = params;</span><br><span class="line">    resolveLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (mParent <span class="keyword">instanceof</span> ViewGroup) &#123;</span><br><span class="line">        ((ViewGroup) mParent).onSetLayoutParams(<span class="keyword">this</span>, params);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 重新执行View的绘制流程，measure-&gt;layout-&gt;draw</span></span><br><span class="line">    requestLayout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>代码中添加View</strong></p>
</li>
</ul>
<p>我们一般会使用ViewGroup的<code>addView()</code>方法来添加子View，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinearLayout llContainer = findViewById(R.id.ll_container);</span><br><span class="line">View child = <span class="keyword">new</span> View(<span class="keyword">this</span>);</span><br><span class="line">llContainer.addView(child);</span><br></pre></td></tr></table></figure>

<p><code>addView()</code>方法有很多个重载方法，上面的代码我只展示了最简单的一个参数的情况，下面我们就来具体看一下所有的重载方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">    addView(child, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot add a null child view to a ViewGroup"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    LayoutParams params = child.getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (params == <span class="keyword">null</span>) &#123;</span><br><span class="line">        params = generateDefaultLayoutParams();</span><br><span class="line">        <span class="keyword">if</span> (params == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"generateDefaultLayoutParams() cannot return null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addView(child, index, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> LayoutParams params = generateDefaultLayoutParams();</span><br><span class="line">    params.width = width;</span><br><span class="line">    params.height = height;</span><br><span class="line">    addView(child, -<span class="number">1</span>, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child, LayoutParams params)</span> </span>&#123;</span><br><span class="line">    addView(child, -<span class="number">1</span>, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child, <span class="keyword">int</span> index, LayoutParams params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DBG) &#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span> + <span class="string">" addView"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot add a null child view to a ViewGroup"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    requestLayout();</span><br><span class="line">    invalidate(<span class="keyword">true</span>);</span><br><span class="line">    addViewInner(child, index, params, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难看出，方法1内部调用了方法2，而在方法2内部会先判断子View是否设置了LayoutParams属性，如果没有设置，就调用<code>generateDefaultLayoutParams()</code>方法创建出一个默认的LayoutParams对象，最后调用方法5。再看方法3和方法4，这两个方法最终同样会调用方法5，因此我们只需要看方法5就好。<br>在此之前，我们先看一下<code>generateDefaultLayoutParams()</code>方法是如何创建出默认的LayoutParams对象的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> LayoutParams <span class="title">generateDefaultLayoutParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，ViewGroup默认创建出LayoutParams对象的宽高属性均为<strong>WRAP_CONTENT</strong>。<br>回到方法5，可以看到最后调用了<code>addViewInner()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addViewInner</span><span class="params">(View child, <span class="keyword">int</span> index, LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">boolean</span> preventRequestLayout)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!checkLayoutParams(params)) &#123;</span><br><span class="line">        params = generateLayoutParams(params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (preventRequestLayout) &#123;</span><br><span class="line">        child.mLayoutParams = params;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        child.setLayoutParams(params);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法内部首先会调用<code>checkLayoutParams()</code>方法检查LayoutParams参数是否合法，如果不合法就调用<code>generateLayoutParams()</code>方法构造一个新的LayoutParams对象，<code>generateLayoutParams()</code>方法我们其实在上面xml文件中添加View的分析中刚见过，不过这里调用的是另一个重载方法，参数为LayoutParams对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">checkLayoutParams</span><span class="params">(ViewGroup.LayoutParams p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  p != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> LayoutParams <span class="title">generateLayoutParams</span><span class="params">(ViewGroup.LayoutParams p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后就是为View设置LayoutParams属性了，这里会判断传入的<code>preventRequestLayout</code>参数值，如果为true就直接对View的mLayoutParams变量赋值；如果为false则调用<code>setLayoutParams()</code>方法来给View设置LayoutParams，这两种情况的区别就是<code>setLayoutParams()</code>方法内部会调用<code>requestLayout()</code>方法来重新进行View的measure、layout和draw流程。可以看到由于<code>addView()</code>方法调用<code>addViewInner()</code>时传入的参数为false，因此这里会执行<code>setLayoutParams()</code>方法。额外提一下，ViewGroup中有一个<code>addViewInLayout()</code>方法，和<code>addView()</code>方法类似，内部也调用了<code>addViewInner()</code>方法，不过该方法可以显式地指定<code>preventRequestLayout</code>参数的值。</p>
<h4 id="自定义LayoutParams须知"><a href="#自定义LayoutParams须知" class="headerlink" title="自定义LayoutParams须知"></a>自定义LayoutParams须知</h4><p>看到这里关于LayoutParams的作用和使用原理基本上就介绍得差不多了，最后再简单介绍自定义LayoutParams。我们在自定义ViewGroup的同时，根据需求可能需要自定义LayoutParams，这里就以我们最熟悉的<strong>LinearLayout</strong>来看一下有哪些需要注意的地方吧。</p>
<ul>
<li><strong>重写generateDefaultLayoutParams()方法</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> LayoutParams <span class="title">generateDefaultLayoutParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOrientation == HORIZONTAL) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>通过前面的分析我们知道<code>generateDefaultLayoutParams()</code>方法的作用是在调用<code>addView()</code>方法时为没有指定LayoutParams的View创建一个默认的LayoutParams对象。对于LinearLayout来说，如果布局方向为水平则子View的宽和高均为<strong>WRAP_CONTENT</strong>；如果布局方向为竖直则子View的宽为<strong>MATCH_PARENT</strong>，高为<strong>WRAP_CONTENT</strong>。</p>
<ul>
<li><strong>重写checkLayoutParams(ViewGroup.LayoutParams p)方法</strong></li>
</ul>
<p><code>checkLayoutParams()</code>方法的作用是检查LayoutParams参数是否合法，我们已经看到了ViewGroup的判断标准为LayoutParams是否非空，那么LinearLayout是如何判断的呢。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">checkLayoutParams</span><span class="params">(ViewGroup.LayoutParams p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p <span class="keyword">instanceof</span> LinearLayout.LayoutParams;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到LinearLayout的判断标准为LayoutParams的类型是否为<strong>LinearLayout.LayoutParams</strong>，在自定义LayoutParams时我们可以根据需要来选择重写该方法。</p>
<ul>
<li><strong>重写generateLayoutParams(ViewGroup.LayoutParams p)方法</strong></li>
</ul>
<p>在<code>checkLayoutParams()</code>方法返回false即LayoutParams不合法的情况下会调用<code>generateLayoutParams()</code>方法重新创建一个合法的LayoutParams，LinearLayout中的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> LayoutParams <span class="title">generateLayoutParams</span><span class="params">(ViewGroup.LayoutParams lp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sPreserveMarginParamsInLayoutParamConversion) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lp <span class="keyword">instanceof</span> LayoutParams) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LayoutParams((LayoutParams) lp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lp <span class="keyword">instanceof</span> MarginLayoutParams) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LayoutParams((MarginLayoutParams) lp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LayoutParams(lp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>generateLayoutParams()</code>方法内部会对传入的LayoutParams进行类型转换，转换为<strong>LinearLayout.LayoutParams</strong>或<strong>ViewGroup.MarginLayoutParams</strong>，这个MarginLayoutParams是什么呢，从名称上也能看出MarginLayoutParams和外边距有关，相比于ViewGroup.LayoutParams，它添加了对外边距的支持，我们平时在xml文件中使用的<strong>layout_margin</strong>和<strong>layout_marginLeft</strong>等属性都是MarginLayoutParams中定义的，而LinearLayout.LayoutParams就是继承自MarginLayoutParams，因此具有设置外边距的几个属性，我们自定义的LayoutParams也可以直接继承自MarginLayoutParams。<br>需要注意的是，虽然这里的<code>generateLayoutParams()</code>方法可以保证LayoutParams类型的正确，但是如果在调用<code>addView()</code>方法后再次设置了LayoutParams，就有可能会报错，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LinearLayout llContainer = findViewById(R.id.ll_container);</span><br><span class="line">View child = <span class="keyword">new</span> View(<span class="keyword">this</span>);</span><br><span class="line">llContainer.addView(child);</span><br><span class="line"><span class="comment">// 在addView()方法后设置了不正确的LayoutParams</span></span><br><span class="line">child.setLayoutParams(<span class="keyword">new</span> ViewGroup.LayoutParams(child.getLayoutParams()));</span><br></pre></td></tr></table></figure>

<p>上述代码运行后会抛出异常<strong>java.lang.ClassCastException: android.view.ViewGroup.LayoutParams cannot be cast to android.widget.LinearLayout.LayoutParams</strong>，原因是在LinearLayout的<code>onMeasure()</code>方法内部会进行强制类型转换操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br></pre></td></tr></table></figure>

<p>因此我们在调用<code>setLayoutParams()</code>还是应该保证传入的LayoutParams类型正确。</p>
<h3 id="measure流程"><a href="#measure流程" class="headerlink" title="measure流程"></a>measure流程</h3><p>前面关于两个类的介绍还是比较详细的，现在终于进入到了measure流程的分析，这里会分为两种情况：单一View的measure和ViewGroup的measure，ViewGroup的measure要复杂一些，因为它不仅需要完成对自身的measure，还要完成对所有子View的measure，我们先分析简单的情况——单一View的measure流程。</p>
<h4 id="单一View的measure流程"><a href="#单一View的measure流程" class="headerlink" title="单一View的measure流程"></a>单一View的measure流程</h4><p>View的measure流程从<code>measure()</code>方法开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到它是一个final声明的方法，因此子类无法重写该方法。在方法内部又调用了我们熟悉的<code>onMeasure</code>方法，我们自定义View时重写的都是该方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法内部调用了<code>setMeasuredDimension()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setMeasuredDimension</span><span class="params">(<span class="keyword">int</span> measuredWidth, <span class="keyword">int</span> measuredHeight)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    setMeasuredDimensionRaw(measuredWidth, measuredHeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setMeasuredDimensionRaw</span><span class="params">(<span class="keyword">int</span> measuredWidth, <span class="keyword">int</span> measuredHeight)</span> </span>&#123;</span><br><span class="line">    mMeasuredWidth = measuredWidth;</span><br><span class="line">    mMeasuredHeight = measuredHeight;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>setMeasuredDimension()</code>方法完成的工作就是为mMeasuredWidth和mMeasuredHeight这两个变量赋值，这两个变量表示View的测量宽高（<strong>与实际宽高有区别，View的实际宽高还取决于layout过程</strong>），我们可以通过<code>getMeasuredWidth()</code>和<code>getMeasuredHeight()</code>方法获取到View测量后的宽高尺寸，即这两个变量的低30位。<br>我们接着来看View的测量宽高是如何得到的，即<code>getDefaultSize()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = size;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">            result = size;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">            result = specSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出当View的测量模式为<strong>AT_MOST</strong>或<strong>EXACTLY</strong>时，View的测量宽/高等于specSize，即MeasureSpec中的测量尺寸；当View的测量模式为<strong>UNSPECIFIED</strong>时，View的测量宽/高等于该方法的第一个参数的值，即<code>getSuggestedMinimumWidth()</code>/<code>getSuggestedMinimumHeight()</code>方法的返回值，这里就以<code>getSuggestedMinimumWidth()</code>方法为例，<code>getSuggestedMinimumHeight()</code>同理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先判断了View是否设置了背景，如果没有设置背景，返回值为mMinWidth，它对应于<strong>android:minWidth</strong>属性所指定的值，如果没有指定则为0；如果View设置了背景，返回值为mMinWidth和<code>mBackground.getMinimumWidth()</code>两者的最大值，<code>getMinimumWidth()</code>方法可以获取到Drawable的原始宽度，但不是所有的Drawable都有原始宽度，如果没有原始宽度，获取到的值就为0（上面这段解释基本上来自《Android开发艺术探索》，目前我对于Drawable的认识还不够，想了解更多的话自行查阅资料吧）。<br>这里也引出了一个问题，当View的测量模式为<strong>AT_MOST</strong>，即LayoutParams指定为wrap_content时，View的测量宽/高等于specSize，而从<code>getChildMeasureSpec()</code>方法的分析中我们也得出此时specSize的值为parentSize，即父View的可用空间大小，这会导致wrap_content产生和match_parent一样的效果，因此我们在自定义View时需要重写<code>onMeasure()</code>方法，解决wrap_content的失效问题，具体做法也很简单，就是为wrap_content情况指定一个默认的宽高尺寸，默认尺寸可以根据需要灵活指定，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    <span class="comment">// 获取宽度的测量模式和测量尺寸</span></span><br><span class="line">    <span class="keyword">int</span> widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    <span class="comment">// 获取高度的测量模式和测量尺寸</span></span><br><span class="line">    <span class="keyword">int</span> heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置wrap_content的默认宽/高值，可以根据需要设置</span></span><br><span class="line">    <span class="keyword">if</span> (getLayoutParams().width == ViewGroup.LayoutParams.WRAP_CONTENT &amp;&amp; getLayoutParams().height == ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">        setMeasuredDimension(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getLayoutParams().width == ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">        setMeasuredDimension(<span class="number">200</span>, heightSize);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getLayoutParams().height == ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">        setMeasuredDimension(widthSize, <span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用一张图总结一下单一View的measure流程：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS1kZmI1MWQwOTE0MDM2YTU1LmpwZw?x-oss-process=image/format,png" alt="View的measure流程.jpg"></p>
<h4 id="ViewGroup的measure流程"><a href="#ViewGroup的measure流程" class="headerlink" title="ViewGroup的measure流程"></a>ViewGroup的measure流程</h4><p>ViewGroup的measure流程同样从<code>measure()</code>方法开始，和View是一样，这里就不展示了，之后会调用<code>onMeasure()</code>方法，但是我们会发现ViewGroup中并没有重写<code>onMeasure()</code>方法，原因其实也不难理解，就是因为每个ViewGroup的布局方式都不一样，无法得出一个统一的实现方式，在自定义ViewGroup时需要根据想要得到的布局效果来重写<code>onMeasure()</code>方法。虽然ViewGroup没有提供<code>onMeasure()</code>方法的实现方式，但是提供了一个<code>measureChildren()</code>方法，从方法名也能猜到是用来测量ViewGroup的所有子View的，我们来看一下这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = children[i];</span><br><span class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</span><br><span class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法内部遍历所有的子View，依次调用<code>measureChild()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> parentHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom, lp.height);</span><br><span class="line"></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>measureChild()</code>方法首先调用此前分析过的<code>getChildMeasureSpec()</code>方法，根据ViewGroup的MeasureSpec和子View自身的LayoutParams确定出子View的MeasureSpec，然后调用子View的<code>measure()</code>方法，对子View进行测量，后面的流程就和单一View的measure流程一样了。我们在自定义ViewGroup时可以在<code>onMeasure()</code>方法调用<code>measureChildren()</code>方法完成对子View的测量。<br>下面以ViewGroup的子类LinearLayout为例，分析一下它的measure流程，加深一下对ViewGroup的measure流程的理解。首先来看<code>onMeasure()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">        measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>onMeasure()</code>方法中会判断LinearLayout的布局方向执行相应的方法，这里就以竖直方向的<code>measureVertical()</code>为例进行分析，水平方向是类似的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">measureVertical</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于记录竖直方向的总高度</span></span><br><span class="line">    mTotalLength = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">float</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 对子View进行measure</span></span><br><span class="line">        measureChildBeforeLayout(child, i, widthMeasureSpec, <span class="number">0</span>,</span><br><span class="line">                heightMeasureSpec, usedHeight);</span><br><span class="line">        <span class="comment">// 获取子View测量后的高</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">        <span class="comment">// 每测量一个子View，mTotalLength就会增加，增加的高度包括子View和高度和竖直方向上的margin</span></span><br><span class="line">        mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">                lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 计算竖直方向的padding</span></span><br><span class="line">    mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line">    <span class="keyword">int</span> heightSize = mTotalLength;</span><br><span class="line">    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</span><br><span class="line">    <span class="comment">// 完成自身高度的measure</span></span><br><span class="line">    <span class="keyword">int</span> heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">    heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 宽度的measure</span></span><br><span class="line">    maxWidth += mPaddingLeft + mPaddingRight;</span><br><span class="line">    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">            heightSizeAndState);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法很长，省略了大量代码，说一下简单的流程吧，高度上，LinearLayout首先会遍历所有子View，调用<code>measureChildBeforeLayout()</code>方法对子View进行测量，每测量一个子View，就增加mTotalLength的值，它表示LinearLayout在竖直方向上的总高度，增加的值包括子View的测量高度和子VIew竖直方向上的margin，当所有子View测量完成后，会计算LinearLayout自身的padding值，最后调用<code>resolveSizeAndState()</code>方法完成对自身高度的测量。宽度上和单一View的测量类似，不需要考虑子View，调用<code>resolveSizeAndState()</code>完成对自身宽度的测量。方法最后依然是调用<code>setMeasuredDimension()</code>设置LinearLayout的测量宽高。接下来我们来看一下LinearLayout测量自身的方法<code>resolveSizeAndState()</code>，这个方法是在View中定义的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">resolveSizeAndState</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec, <span class="keyword">int</span> childMeasuredState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> result;</span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">            <span class="keyword">if</span> (specSize &lt; size) &#123;</span><br><span class="line">              	<span class="comment">// 子View的测量总高度超过了LinearLayout可用空间大小</span></span><br><span class="line">                result = specSize | MEASURED_STATE_TOO_SMALL;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = size;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">            result = specSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result | (childMeasuredState &amp; MEASURED_STATE_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，如果LinearLayout的测量模式为<strong>EXACTLY</strong>，那么最终的测量高度为specSize，与子View无关；如果LinearLayout的测量模式为<strong>AT_MOST</strong>，会判断子View的总高度（包括margin、paddding）是否超过了LinearLayout竖直方向上的可用空间，如果没超过则最终测量高度为子View的总高度，如果超过了则最终测量高度为specSize，并设置一个<strong>MEASURED_STATE_TOO_SMALL</strong>标志。<br>值得一提的是，LinearLayout的测量有一种特殊情况，就是对于自身的测量模式为<strong>EXACTLY</strong>并且子View设置了layout_weight的情况，这种情况会在后面重新进行一次子View的遍历和测量，由于这不是ViewGroup测量的通用流程，这里就不细说了，感兴趣的话可以查看一下这块的源码。<br>最后用一张图总结一下ViewGroup的measure流程，虽然具体到每个ViewGroup的measure流程可能会有所不同，但是这几个步骤是通用的。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS04MzExNDI5NWY0NDQyZDMyLmpwZw?x-oss-process=image/format,png" alt="ViewGroup的measure流程.jpg"><br>既然ViewGroup和View的measure流程都已经分析完了，我们可以梳理一下一个页面的完整measure流程，首先从ViewRootImpl的<code>performMeasure()</code>方法开始对顶层View——DecorView进行测量，调用<code>measure()</code>方法，由于DecorView继承自FrameLayout，可以看做一个ViewGroup，因此接着会遍历DecorVIew的所有子View进行测量，如果子View是一个单一View，只需要完成自身的测量，如果子View是一个ViewGroup，就又会重复上面的步骤，遍历该子View下的所有子View进行测量，之后便是一个递归的过程，最后当所有子View的测量都完成后，再进行DecorVIew自身的测量。</p>
<h3 id="补充：MeasureSpec-UNSPECIFIED的应用"><a href="#补充：MeasureSpec-UNSPECIFIED的应用" class="headerlink" title="补充：MeasureSpec.UNSPECIFIED的应用"></a>补充：MeasureSpec.UNSPECIFIED的应用</h3><p>我们此前介绍<strong>UNSPECIFIED</strong>模式的时候基本上是一笔带过的，只介绍了该模式下是父View不限制子View大小，用于系统内部，开发中一般很少会用到，虽然是这样，我们还是有必要了解一下该模式的常见应用场景，可能我们平时在开发中已经接触过了，只是没有发现而已。<br>ScrollView相信大家都很熟悉了，在使用时有一个需要注意的地方，就是当ScrollView的子布局没有占满屏幕高度时，它的子View是无法占满全屏的，即使设置了layout_height为<strong>match_parent</strong>也不管用，可能大家都已经知道了这个问题，我这里就简单展示一下。布局文件很简单，ScrollView嵌套一个LinearLayout，LinearLayout中有一个高度为100dp的TextView。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ScrollView</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#f00"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">"I can do all things"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">"#fff"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">"24sp"</span> /&gt;</span></span><br><span class="line">      </span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">ScrollView</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行效果如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS1lZDEzNWZjZGUyZTcyNzNiLmpwZw?x-oss-process=image/format,png" alt><br>可以看出LinearLayout的高度为100dp，并没有占满屏幕，但是我们明明设置了layout_height为<strong>match_parent</strong>，其实不止这样，即便是layout_height指定了精确数值（如200dp）也不会生效。解决方案就是为ScrollView添加<strong>android:fillViewport=”true”</strong>属性，运行之后发现LinearLayout可以占满全屏了。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS0zMGIyZDgwNTQwZjdjMmIyLmpwZw?x-oss-process=image/format,png" alt><br>现在我们从源码角度分析一下产生这个问题的原因，看一下ScrollView的<code>onMeasure()</code>方法：<br><strong>ScrollView的onMeasure方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mFillViewport) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">if</span> (heightMode == MeasureSpec.UNSPECIFIED) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getChildCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getChildAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> widthPadding;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> heightPadding;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion;</span><br><span class="line">        <span class="keyword">final</span> FrameLayout.LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">        <span class="keyword">if</span> (targetSdkVersion &gt;= VERSION_CODES.M) &#123;</span><br><span class="line">            widthPadding = mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin;</span><br><span class="line">            heightPadding = mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            widthPadding = mPaddingLeft + mPaddingRight;</span><br><span class="line">            heightPadding = mPaddingTop + mPaddingBottom;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> desiredHeight = getMeasuredHeight() - heightPadding;</span><br><span class="line">        <span class="keyword">if</span> (child.getMeasuredHeight() &lt; desiredHeight) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(</span><br><span class="line">                    widthMeasureSpec, widthPadding, lp.width);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                    desiredHeight, MeasureSpec.EXACTLY);</span><br><span class="line">            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>onMeasure()</code>方法中首先会判断mFillViewport的值，如果为false则直接return，不执行后面的逻辑。从变量名不难猜到这个mFillViewport就是对应于<strong>android:fillViewport</strong>属性，默认值为false，因此当我们没有设置<strong>android:fillViewport=”true”</strong>时，<code>onMeasure()</code>方法只会执行父类的<code>onMeasure()</code>方法。我们先简单看一下后面的代码，首先计算出ScrollView的可用高度desiredHeight，当<code>child.getMeasuredHeight() &lt; desiredHeight</code>，即子View的测量高度小于ScrollView的可用高度时，会将子View高度的测量模式指定为<strong>EXACTLY</strong>，测量尺寸指定为ScrollView的可用高度并进行重新测量，因此子View的最终测量高度就是ScrollView的可用高度，对于上面的例子来说Linearlayout自然就占满了全屏。<br>清楚了<strong>android:fillViewport=”true”</strong>属性为什么可以让子View占满全屏后，我们再来分析一下为什么默认情况下子View不会占满全屏，由于默认情况只会执行父类的<code>onMeasure()</code>方法，我们来看一下ScrollView的父类FrameLayout的<code>onMeasure()</code>方法。<br><strong>FrameLayout的onMeasure方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = getChildCount();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">            resolveSizeAndState(maxHeight, heightMeasureSpec,</span><br><span class="line">                    childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FrameLayout的<code>onMeasure()</code>方法内部调用了<code>measureChildWithMargins()</code>方法来对子View进行测量，ScrollView重写了该方法，我们来看一下：<br><strong>ScrollView的measureChildWithMargins方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                    + widthUsed, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> usedTotal = mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin +</span><br><span class="line">            heightUsed;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = MeasureSpec.makeSafeMeasureSpec(</span><br><span class="line">            Math.max(<span class="number">0</span>, MeasureSpec.getSize(parentHeightMeasureSpec) - usedTotal),</span><br><span class="line">            MeasureSpec.UNSPECIFIED);</span><br><span class="line"></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出ScrollView在测量子View时，将子VIew高度的测量模式直接指定为了<strong>UNSPECIFIED</strong>，还记得我们上面分析过的LinearLayout的measure过程吗，在子View测量完成后，会调用<code>resolveSizeAndState()</code>方法完成自身的测量，这里再贴一遍代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">resolveSizeAndState</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec, <span class="keyword">int</span> childMeasuredState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> result;</span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">            <span class="keyword">if</span> (specSize &lt; size) &#123;</span><br><span class="line">              	<span class="comment">// 子View的测量总高度超过了LinearLayout可用空间大小</span></span><br><span class="line">                result = specSize | MEASURED_STATE_TOO_SMALL;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = size;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">            result = specSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result | (childMeasuredState &amp; MEASURED_STATE_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，当LinearLayout的测量模式为<strong>UNSPECIFIED</strong>时，LinearLayout的测量高度为子View的总高度size，因此当LinearLayout子View的总高度小于LinearLayout指定的高度时，LinearLayout的高度不会生效。<br>看到这里我们清楚了ScrollView子View无法占满全屏的原因，也见到了<strong>UNSPECIFIED</strong>的应用场景，其实不止ScrollView，<strong>UNSPECIFIED</strong>模式在其他的一些可滚动的ViewGroup中也有应用，比如RecyclerView。和<strong>WRAP_CONTENT</strong>相比，<strong>UNSPECIFIED</strong>模式不会限制View的大小，正是如此，<strong>UNSPECIFIED</strong>模式非常适合应用到可滚动的ViewGroup中，此时ViewGroup不必关心子View的大小是否超出了自身范围，即时超出了也可以通过滚动来查看。<br>我们在自定义View时该如何处理<strong>UNSPECIFIED</strong>的情况呢，这里引用一下<a href="https://www.wanandroid.com/wenda/show/8613" target="_blank" rel="noopener">每日一问 详细的描述下自定义 View 测量时 MesureSpec.UNSPECIFIED</a>中陈小缘大佬的回答，解释得很好。当遇到<strong>UNSPECIFIED</strong>时就比较自由了，既然尺寸由自己决定，那么可以写死为50，也可以固定为200，但还是建议结合实际需求来定义，比如ImageView，它的做法就是：有设置图片内容(drawable)的话，会直接使用这个drawable的尺寸，但不会超过指定的MaxWidth或MaxHeight， 没有内容的话就是0；而TextView处理<strong>UNSPECIFIED</strong>的方式，和<strong>AT_MOST</strong>是一样的。</p>
<h2 id="layout阶段"><a href="#layout阶段" class="headerlink" title="layout阶段"></a>layout阶段</h2><p>measure流程的作用是对View的大小进行测量，而layout的作用就是根据测量大小确定View的最终位置，简单地说就是把View放在哪。和measure流程类似，layout流程同样分为两种情况：单一View的layout和ViewGroup的layout，ViewGroup的layout流程要复杂一些，因为它不仅要进行自身的layout，还要对所有子View进行layout，我们先来看看单一View的layout流程。</p>
<h3 id="单一View的layout流程"><a href="#单一View的layout流程" class="headerlink" title="单一View的layout流程"></a>单一View的layout流程</h3><p>View的layout流程从<code>layout()</code>方法开始，我们来看一下这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">int</span> oldL = mLeft;</span><br><span class="line">    <span class="keyword">int</span> oldT = mTop;</span><br><span class="line">    <span class="keyword">int</span> oldB = mBottom;</span><br><span class="line">    <span class="keyword">int</span> oldR = mRight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>layout()</code>方法内部会根据<code>isLayoutModeOptical()</code>的返回值调用<code>setOpticalFrame()</code>方法或<code>setFrame()</code>方法，<code>isLayoutModeOptical()</code>方法会判断<strong>LAYOUT_MODE_OPTICAL_BOUNDS</strong>标志位，它表示一个布局模式，从名称上看应该是和布局边界有关，具体作用我也不是很了解，不过默认情况下都是没有设置该标志位的。这里可以暂且先不去管它的作用，我们会发现<code>setOpticalFrame()</code>方法内部最终还是会调用<code>setFrame()</code>方法，因此直接来看<code>setFrame()</code>方法就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setOpticalFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    Insets parentInsets = mParent <span class="keyword">instanceof</span> View ?</span><br><span class="line">            ((View) mParent).getOpticalInsets() : Insets.NONE;</span><br><span class="line">    Insets childInsets = getOpticalInsets();</span><br><span class="line">    <span class="keyword">return</span> setFrame(</span><br><span class="line">            left   + parentInsets.left - childInsets.left,</span><br><span class="line">            top    + parentInsets.top  - childInsets.top,</span><br><span class="line">            right  + parentInsets.left + childInsets.right,</span><br><span class="line">            bottom + parentInsets.top  + childInsets.bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> changed = <span class="keyword">false</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;</span><br><span class="line">        changed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        mLeft = left;</span><br><span class="line">        mTop = top;</span><br><span class="line">        mRight = right;</span><br><span class="line">        mBottom = bottom;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>setFrame()</code>方法首先会判断根据<code>mLeft != left || mRight != right || mTop != top || mBottom != bottom</code>，即View的位置是否发生了改变，如果发生了改变，则返回值为true，反之返回值为false。如果View的位置发生了改变，会重新为View的四个顶点位置赋值，对应四个成员变量mLeft、mTop、mRight和mBottom，关于这四个值我们通过一个示意图就可以很清楚了，图片摘自<a href="https://www.gcssloop.com/#blog" target="_blank" rel="noopener">GcsSloop大佬的博客</a>。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS0yMmU3NWY1ZDk2NzIyNGQ5LmpwZw?x-oss-process=image/format,png" alt><br>首次layout 前这四个变量都没有赋过值，因此这里<code>setFrame()</code>方法会返回true，我们回到<code>layout()</code>方法，changed的值就为true，接下来会执行<code>onLayout()</code>方法，我们接着来看<code>onLayout()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>View中的<code>onLayout()</code>是一个空方法，没有声明任何逻辑，这是因为<code>layout()</code>方法已经确定了View的四个顶点的位置，而<code>onLayout()</code>方法是用于ViewGroup确定子View的位置，我们会再来分析。<br>单一View的layout流程就分析完了，是不是很简单，用一张流程图总结一下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS1iMjMwMmY0YWZkMWM1MWNhLmpwZw?x-oss-process=image/format,png" alt="View的layout流程.jpg"></p>
<h3 id="ViewGroup的layout流程"><a href="#ViewGroup的layout流程" class="headerlink" title="ViewGroup的layout流程"></a>ViewGroup的layout流程</h3><p>ViewGroup的layout流程同样从<code>layout()</code>方法开始，我们来看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">  	<span class="keyword">super</span>.layout(l, t, r, b);</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ViewGroup的<code>layout()</code>方法使用final声明，因此子类无法重写该方法。<code>layout()</code>方法中调用了父类即View的<code>layout()</code>方法，确定了ViewGroup自身的四个顶点位置，并调用<code>onLayout()</code>方法，我们来看一下ViewGroup的<code>onLayout()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可以发现ViewGroup的<code>onLayout()</code>方法是一个抽象方法，因此当我们自定义ViewGroup时需要重写该方法。ViewGroup没有实现<code>onLayout()</code>方法的原因同样是因为不同的ViewGroup具有不同的布局方式，无法得出一个统一实现。在自定义ViewGroup中的<code>onLayout()</code>方法中我们需要遍历所有的子View，根据需要的布局方式调用子View的<code>layout()</code>方法确定子View的位置。<br>这样说可能不是很清楚，接下来我们同样以LinearLayout为例，看一下它的layout流程，加深我们对ViewGroup的 layout流程的理解。由于ViewGroup的<code>layout()</code>方法无法被子类重写，因此我们直接来看LinearLayout的<code>onLayout()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">        layoutVertical(l, t, r, b);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        layoutHorizontal(l, t, r, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和LinearLayout的<code>onMeasure()</code>方法类似，<code>onlayout()</code>方法中同样会根据LinearLayout的布局方向执行相应的布局方法，我们以竖直方向布局为例，分析一下<code>layoutVertical()</code>方法，水平方向同理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutVertical</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  	<span class="comment">// childTop和childLeft记录子View的左上位置</span></span><br><span class="line">    <span class="keyword">int</span> childTop;</span><br><span class="line">  	<span class="keyword">int</span> childLeft;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> LinearLayout.LayoutParams lp =</span><br><span class="line">                (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        childTop += lp.topMargin;</span><br><span class="line">        setChildFrame(child, childLeft, childTop + getLocationOffset(child),</span><br><span class="line">                childWidth, childHeight);</span><br><span class="line">      	<span class="comment">// 每完成一个子View的layout，childTop就会增加</span></span><br><span class="line">        childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);</span><br><span class="line"></span><br><span class="line">        i += getChildrenSkipCount(child, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>layoutVertical()</code>方法内部遍历了LinearLayout的所有子View，每次遍历都调用<code>setChildFrame()</code>方法，我们来看一下这个方法：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> setChildFrame(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> <span class="built_in">width</span>, <span class="keyword">int</span> <span class="built_in">height</span>) &#123;</span><br><span class="line">    child.layout(left, top, left + <span class="built_in">width</span>, top + <span class="built_in">height</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>setChildFrame()</code>方法其实就是调用了子View的<code>layout()</code>方法，完成子View的布局。<code>setChildFrame()</code>方法调用完成后，会增加childTop的值，它对应子View的mTop，继续下一个子View的layout，还是比较好理解的，竖直方向的LinearLayout的子View是一个接一个往下放置的。<br>总结一下ViewGroup的layout流程，首先会调用<code>layout()</code>方法确定自身的位置，之后调用<code>onLayout()</code>方法，遍历所有的子View，根据ViewGroup的布局特性依次确定出每个子View的位置。流程图如下所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS0zMjQ5YzkxNjJkNjVjNGM0LmpwZw?x-oss-process=image/format,png" alt="ViewGroup的layout流程.jpg"><br>ViewGroup的layout流程和measure流程还是很相似的，不过在顺序上有一些区别，measure是先遍历子View对子View进行测量，最后根据子View的测量结果对ViewGroup自身进行测量；而layout是先确定ViewGroup的位置，再遍历子View确定子View的位置。<br>最后我们来梳理一下整个页面的layout过程，前面也提到过，页面的layout流程从ViewRootImpl的<code>performLayout()</code>方法开始。<br><strong>ViewRootImpl的performLayout方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLayout</span><span class="params">(WindowManager.LayoutParams lp, <span class="keyword">int</span> desiredWindowWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">final</span> View host = mView;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法内部首先将mView赋值给host，这里的mView我此前也提到过，就是在<code>handleResumeActivity()</code>方法中调用<code>wm.addView(decor,l)</code>时传过来的DecorView，因此后面调用host的<code>layout()</code>方法实际上就是调用DecorView的<code>layout()</code>方法，从这里就开始最顶层VIew的layout，而我们知道DecorView继承自FrameLayout，因此这里就是执行ViewGroup的<code>layout()</code>方法，之后的步骤我们就清楚了，首先确定出DecorView的位置，然后调用<code>onlayout()</code>方法遍历DecorView的子View，依次调用子View的<code>layout()</code>方法来确定子View的位置，如果子View是一个ViewGroup，还需要接着遍历子View的所有子View进行layout。</p>
<h3 id="getMeasureWidth-getMeasureHeight和getWidth-getHeight的区别"><a href="#getMeasureWidth-getMeasureHeight和getWidth-getHeight的区别" class="headerlink" title="getMeasureWidth/getMeasureHeight和getWidth/getHeight的区别"></a>getMeasureWidth/getMeasureHeight和getWidth/getHeight的区别</h3><p>我在View的measure流程中提到过measure完成后可以通过<code>getMeasuredWidth()</code>和<code>getMeasuredHeight()</code>方法获取View的测量宽高，但是这个测量宽高并不等于View的最终实际宽高，现在就来解释一下这个问题。<br>我们知道View的宽高可以通过<code>getWidth()</code>和<code>getHeight()</code>方法来获得，首先来看一下这几个方法的定义，这里就只对比<code>getMeasureWidth()</code>和<code>getWidth()</code>方法，<code>getMeasuredHeight()</code>方法和<code>getHeight()</code>方法的区别同理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getMeasuredWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMeasuredWidth &amp; MEASURED_SIZE_MASK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getMeasuredHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMeasuredHeight &amp; MEASURED_SIZE_MASK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mRight - mLeft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBottom - mTop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getMeasuredWidth()</code>获取到是mMeasuredWidth的低30位，而mMeasuredWidth是在<code>onMeasure()</code>方法中通过<code>setMeasuredDimension()</code>赋值的。<code>getWidth()</code>获取到的是<code>mRight - mLeft</code>，这两个都是在<code>layout()</code>方法中通过<code>setFrame()</code>赋值的。这样看上去两者获取到的值好像没有什么联系，我们可以再回头看一下<code>layout()</code>方法传入的left和right参数的值，就以刚介绍过的DecorView为例吧，left参数传入了0，right参数传入了<code>host.getMeasuredWidth()</code>，因此最后计算出的<code>mRight - mLeft</code>就是<code>getMeasureWidth()</code>方法的返回值。其实不止DecorView，所有的View<strong>在默认情况下<code>getWidth()</code>的值和<code>getMeasureWidth()</code>的值都是一样</strong>的，需要注意这里强调的是<strong>默认情况下</strong>，那么什么情况下这两个方法的返回值不一样呢？<br>我们可以重写View的<code>layout()</code>方法，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.layout(l, t, r + <span class="number">100</span>, b + <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就会导致<code>getWidth()</code>/<code>getHeight()</code>获取到的值比<code>getMeasureWidth()</code>/<code>getMeasureHeight()</code>获取到的值大100px，虽然一般情况下不会这样做，只是为了让我们更加清楚<code>getWidth()</code>/<code>getHeight()</code>和<code>getMeasureWidth()</code>/<code>getMeasureHeight()</code>的区别。</p>
<h2 id="draw阶段"><a href="#draw阶段" class="headerlink" title="draw阶段"></a>draw阶段</h2><p>通过前面的measure和layout两个流程，已经确定出了View的大小和位置，接下里就要把View显示出来了，draw的作用是就将View绘制到屏幕上。相比于前两个流程，View的绘制流程是最简单的，因为源码的逻辑很少，基本上都要靠我们自己去定义如何绘制。同样地，我们分两种情况进行分析，包括单一View的绘制和ViewGroup的绘制。</p>
<h3 id="单一View的draw流程"><a href="#单一View的draw流程" class="headerlink" title="单一View的draw流程"></a>单一View的draw流程</h3><p>View的绘制流程从<code>draw()</code>方法开始，我们来看一下这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!dirtyOpaque) &#123;</span><br><span class="line">        <span class="comment">// 第一步、绘制背景</span></span><br><span class="line">        drawBackground(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">        <span class="comment">// 第二步、绘制自身内容</span></span><br><span class="line">        <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line">        <span class="comment">// 第三步、绘制子View</span></span><br><span class="line">        dispatchDraw(canvas);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 第四布、绘制装饰，包括滚动条和前景</span></span><br><span class="line">        onDrawForeground(canvas);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里精简了一下源码，可以直观地看出View的<code>draw()</code>方法分为四个步骤（源码中提到了6个步骤，另外两个可以跳过的，这里就不列入了）：</p>
<ul>
<li>调用<code>drawBackground()</code>方法绘制背景</li>
<li>调用<code>onDraw()</code>方法绘制自身内容</li>
<li>调用<code>dispatchDraw()</code>方法绘制子View</li>
<li>调用<code>onDrawForeground()</code>方法绘制装饰，包括滚动条和前景</li>
</ul>
<p>下面我们就来分别看一下这四个方法。<br><strong>View的drawBackground方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawBackground</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取背景Drawable</span></span><br><span class="line">    <span class="keyword">final</span> Drawable background = mBackground;</span><br><span class="line">    <span class="keyword">if</span> (background == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据layout流程确定出的四个顶点位置设置背景的边界</span></span><br><span class="line">    setBackgroundBounds();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取水平和竖直方向上的滑动距离</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> scrollX = mScrollX;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> scrollY = mScrollY;</span><br><span class="line">    <span class="comment">// 绘制背景</span></span><br><span class="line">    <span class="keyword">if</span> ((scrollX | scrollY) == <span class="number">0</span>) &#123;</span><br><span class="line">        background.draw(canvas);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        canvas.translate(scrollX, scrollY);</span><br><span class="line">        background.draw(canvas);</span><br><span class="line">        canvas.translate(-scrollX, -scrollY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>drawBackground()</code>方法首先会获取背景Drawable，如果没有设置背景则直接返回；如果设置了背景就调用Drawable的<code>draw()</code>方法完成背景的绘制，代码的逻辑还是比较简单的，我就不详细说了。<br><strong>View的onDraw方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>onDraw()</code>方法可以说是我们在自定义View中最熟悉的，View的<code>onDraw()</code>是一个空方法，需要子类自己决定如何进行绘制。<br><strong>View的dispatchDraw方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>View的<code>dispatchDraw()</code>方法同样是一个空方法，它的作用是对子View进行绘制，因此单一View自然无需实现该方法，我们稍后会看一下ViewGroup中是如何实现该方法的。<br><strong>View的onDrawForeground方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawForeground</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绘制滚动条</span></span><br><span class="line">  	onDrawScrollIndicators(canvas);</span><br><span class="line">    onDrawScrollBars(canvas);</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 绘制前景</span></span><br><span class="line">    <span class="keyword">final</span> Drawable foreground = mForegroundInfo != <span class="keyword">null</span> ? mForegroundInfo.mDrawable : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (foreground != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mForegroundInfo.mBoundsChanged) &#123;</span><br><span class="line">            mForegroundInfo.mBoundsChanged = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">final</span> Rect selfBounds = mForegroundInfo.mSelfBounds;</span><br><span class="line">            <span class="keyword">final</span> Rect overlayBounds = mForegroundInfo.mOverlayBounds;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mForegroundInfo.mInsidePadding) &#123;</span><br><span class="line">                selfBounds.set(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                selfBounds.set(getPaddingLeft(), getPaddingTop(),</span><br><span class="line">                        getWidth() - getPaddingRight(), getHeight() - getPaddingBottom());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> ld = getLayoutDirection();</span><br><span class="line">            Gravity.apply(mForegroundInfo.mGravity, foreground.getIntrinsicWidth(),</span><br><span class="line">                    foreground.getIntrinsicHeight(), selfBounds, overlayBounds, ld);</span><br><span class="line">            foreground.setBounds(overlayBounds);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        foreground.draw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>onDrawForeground()</code>方法用于绘制View的一些装饰，包括滚动条和前景，我们一般很少接触到该方法，就不具体分析了。<br>用一张流程图总结一下单一View的draw流程：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS0wOTAyYzEwY2ZiYzJlOGYxLmpwZw?x-oss-process=image/format,png" alt="View的draw流程.jpg"><br>虽然View的绘制流程可以分为以上四步，但是我们在自定义View中只需要重写<code>onDraw()</code>方法，按需要进行绘制就可以了。</p>
<h3 id="ViewGroup的draw流程"><a href="#ViewGroup的draw流程" class="headerlink" title="ViewGroup的draw流程"></a>ViewGroup的draw流程</h3><p>ViewGroup的绘制同样从<code>draw()</code>方法开始，也可分为和View相同的四个步骤，这里要重点分析一下第三步调用的<code>dispatchDraw()</code>方法，ViewGroup重写了该方法。其他三个步骤和View是一样的，这里就不再分析了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 遍历子View</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">final</span> View transientChild = mTransientViews.get(transientIndex);</span><br><span class="line">        <span class="keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||</span><br><span class="line">                transientChild.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 绘制子View</span></span><br><span class="line">            more |= drawChild(canvas, transientChild, drawingTime);</span><br><span class="line">        &#125;</span><br><span class="line">        transientIndex++;</span><br><span class="line">        <span class="keyword">if</span> (transientIndex &gt;= transientCount) &#123;</span><br><span class="line">            transientIndex = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dispatchDraw()</code>方法内部主要做的就是遍历所有的子View，依次调用<code>drawChild</code>方法，<code>drawChild</code>方法内部又会调用子View的<code>draw()</code>方法，注意，这里调用的<code>draw()</code>方法并不是此前分析过的那个，它有三个参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(Canvas canvas, ViewGroup parent, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</span><br><span class="line">    	mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">    	dispatchDraw(canvas);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	draw(canvas);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里省略了大量代码，可以看出该方法内部会根据条件执行一个参数的<code>draw()</code>方法（执行的条件我后面会分析），后面的流程就和单一View的绘制流程相同了。<br>总结一下ViewGroup的draw流程，整体步骤和单一View的draw流程是一样的，不同的是ViewGroup重写了<code>dispatchDraw()</code>方法，在内部遍历子View并完成子View的绘制。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS1mOWUyYjNjNWZlODgwY2YxLmpwZw?x-oss-process=image/format,png" alt="ViewGroup的draw流程.jpg"><br>最后还是来梳理一下整个页面的draw流程，从ViewRootImpl的<code>performDraw()</code>方法开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">boolean</span> canUseAsync = draw(fullRedrawNeeded);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      	<span class="comment">// 开启了硬件加速</span></span><br><span class="line">        mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class="keyword">this</span>, callback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      	<span class="comment">// 关闭了硬件加速</span></span><br><span class="line">        <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset,</span><br><span class="line">                scalingRequired, dirty, surfaceInsets)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> useAsyncReport;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>performDraw()</code>方法内部又会调用<code>draw()</code>方法，在<code>draw()</code>方法中会根据是否开启了硬件加速执行相应的逻辑，硬件加速就是通过引入GPU来提高绘制和界面刷新的效率，不过也有可能导致自定义View出现问题，在API 13（Android 4.0）及以上版本中，硬件加速是默认开启的，我们可以手动关闭硬件加速。关于硬件加速我也了解得不多，这里就不多提了，感兴趣的话可以查阅一下相关资料。下面我们就分别看一下开启和关闭硬件加速的情况下都是如何完成页面绘制的吧。</p>
<ul>
<li><strong>关闭硬件加速</strong></li>
</ul>
<p>关闭硬件加速的情况下会执行<code>drawSoftware()</code>方法，我们来看一下这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">boolean</span> scalingRequired, Rect dirty, Rect surfaceInsets)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mView.draw(canvas);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法内部会调用mView的<code>draw()</code>方法，这里的mView是DecorView，前面已经分析过了，因此现在进入了DecorView的绘制流程，接下来就和ViewGroup的绘制流程一样了，即遍历DecorView的所有子View，完成子View的绘制，如果子View是一个ViewGroup则重复该过程，直到所有的子View都绘制完成。</p>
<ul>
<li><strong>开启硬件加速</strong></li>
</ul>
<p>开启硬件加速的情况下会执行<code>mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, this, callback)</code>，mThreadedRenderer的类型为<strong>ThreadedRenderer</strong>，我们来看一下ThreadedRenderer的<code>draw()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(View view, AttachInfo attachInfo, DrawCallbacks callbacks,</span></span></span><br><span class="line"><span class="function"><span class="params">          FrameDrawingCallback frameDrawingCallback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    updateRootDisplayList(view, callbacks);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateRootDisplayList</span><span class="params">(View view, DrawCallbacks callbacks)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    updateViewTreeDisplayList(view);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateViewTreeDisplayList</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    view.mPrivateFlags |= View.PFLAG_DRAWN;</span><br><span class="line">    view.mRecreateDisplayList = (view.mPrivateFlags &amp; View.PFLAG_INVALIDATED)</span><br><span class="line">            == View.PFLAG_INVALIDATED;</span><br><span class="line">    view.mPrivateFlags &amp;= ~View.PFLAG_INVALIDATED;</span><br><span class="line">    view.updateDisplayListIfDirty();</span><br><span class="line">    view.mRecreateDisplayList = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过一系列调用最终会调用<code>updateViewTreeDisplayList()</code>方法，这里传入的view为DecorView，方法内部会根据view是否设置了<strong>PFLAG_INVALIDATED</strong>标志位来给成员变量mRecreateDisplayList赋值，由于DecorView没有设置该标志位，因此mRecreateDisplayList的值为false。接下来会调用<code>updateDisplayListIfDirty()</code>方法，它定义在View中，我们来看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RenderNode <span class="title">updateDisplayListIfDirty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RenderNode renderNode = mRenderNode;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == <span class="number">0</span></span><br><span class="line">            || !renderNode.isValid()</span><br><span class="line">            || (mRecreateDisplayList)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (renderNode.isValid()</span><br><span class="line">                &amp;&amp; !mRecreateDisplayList) &#123;</span><br><span class="line">            <span class="comment">// 不需要重新进行绘制</span></span><br><span class="line">            mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">            dispatchGetDisplayList();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> renderNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要重新进行绘制</span></span><br><span class="line">        mRecreateDisplayList = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</span><br><span class="line">              	<span class="comment">// 如果设置了PFLAG_SKIP_DRAW标志位，执行dispatchDraw()方法</span></span><br><span class="line">                DecorView(canvas);</span><br><span class="line">                drawAutofilledHighlight(canvas);</span><br><span class="line">                <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">                    mOverlay.getOverlayView().draw(canvas);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (debugDraw()) &#123;</span><br><span class="line">                    debugDrawFocus(canvas);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             	<span class="comment">// 没有设置PFLAG_SKIP_DRAW标志位，执行draw()方法</span></span><br><span class="line">                draw(canvas);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            renderNode.end(canvas);</span><br><span class="line">            setDisplayListProperties(renderNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> renderNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先来看一下第一个if判断的几个条件：</p>
<ul>
<li><strong>mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID == 0</strong></li>
</ul>
<p>由于DecorView没有设置<strong>PFLAG_DRAWING_CACHE_VALID</strong>标志位，因此该条件满足。</p>
<ul>
<li><strong>!renderNode.isValid()</strong></li>
</ul>
<p><code>isValid()</code>方法字面意思上是判断renderNode是否有效，那么什么时候是有效的呢？我们会发现<code>updateDisplayListIfDirty()</code>方法最后调用了<code>renderNode.end(canvas)</code>，点进这个<code>end()</code>方法看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ends the recording for this display list. A display list cannot be</span></span><br><span class="line"><span class="comment"> * replayed if recording is not finished. Calling this method marks</span></span><br><span class="line"><span class="comment"> * the display list valid and &#123;<span class="doctag">@link</span> #isValid()&#125; will return true.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #start(int, int)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #isValid()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">(DisplayListCanvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> displayList = canvas.finishRecording();</span><br><span class="line">    nSetDisplayList(mNativeRenderNode, displayList);</span><br><span class="line">    canvas.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从注释<strong>Calling this method marks the display list valid and isValid() will return true</strong>中可以看出当调用了<code>end()</code>方法后，<code>isValid()</code>会返回true，由于此时是页面首次绘制，还没有调用过<code>end()</code>方法，因此<code>isValid()</code>返回false，<code>!renderNode.isValid()</code>为true，该条件满足。</p>
<ul>
<li><strong>mRecreateDisplayList</strong></li>
</ul>
<p>上面也说过了，由于设置<strong>PFLAG_INVALIDATED</strong>标志位，此时DecorView的mRecreateDisplayList值为false，该条件不满足。<br>由于满足了两个条件，因此会进入到第一个if判断中，接下来又是一个if判断，判断条件是<code>renderNode.isValid() &amp;&amp; !mRecreateDisplayList</code> ，根据上面的分析，该条件不满足，因此不会执行if中的逻辑。接下来会判断是否设置了<strong>PFLAG_SKIP_DRAW</strong>标志位，关于这个标志位的作用我后面会分析，这里先记住ViewGroup默认情况下都会设置这个标志位，由于DecorView就是一个ViewGroup，会设置该标志位，因此会执行<code>dispatchDraw()</code>方法，遍历所有子View，完成对子View的绘制，如果子View是一个ViewGroup则接着遍历下面的子View，直到所有子View都完成绘制。</p>
<h3 id="ViewGroup的draw-方法调用问题"><a href="#ViewGroup的draw-方法调用问题" class="headerlink" title="ViewGroup的draw()方法调用问题"></a>ViewGroup的draw()方法调用问题</h3><p>首先介绍几个Android中常见的位运算，有助于我们更好地理解源码：</p>
<blockquote>
<p><strong>a | b</strong>：为a添加标志位b<br><strong>(a &amp; b) != 0</strong>：判断a是否有标志位b<br><strong>a &amp; ~b</strong>：为a清除标志位b<br><strong>a^b</strong>：取出a与b的不同部分</p>
</blockquote>
<p>感叹一下，位运算在Android中还是很常见的，尤其是在View的源码中，熟悉上面这个几个位运算操作对我们阅读源码还是有很大帮助的。<br>下面进入正题，当我们的自定义View继承自ViewGroup时会遇到一个问题，默认情况下<code>draw()</code>方法和<code>onDraw()</code>方法都不会被调用，只会调用了<code>dispatchDraw()</code>方法，可以自己尝试一下，我这里就不展示了。我们下面就来分析一下原因，首先来看上面分析过的三个参数的<code>draw()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(Canvas canvas, ViewGroup parent, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</span><br><span class="line">    	mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">    	dispatchDraw(canvas);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	draw(canvas);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是在父View遍历子VIew依次调用<code>drawChild()</code>方法后被调用的，可以很明显地看出当满足<code>(mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW</code>条件时，执行<code>dispatchDraw(canvas)</code>方法，不满足条件就执行一个参数的<code>draw()</code>方法，进而执行<code>onDraw()</code>方法。<strong>mPrivateFlags</strong>是View中定义的一个全局变量，用于存储各种标志位，上面的条件就是判断mPrivateFlags是否设置了<strong>PFLAG_SKIP_DRAW</strong>标志位。既然ViewGroup默认情况下不会执行<code>draw()</code>方法，那么肯定是设置了<strong>PFLAG_SKIP_DRAW</strong>标志位，是在什么时候设置的呢？我们发现在ViewGroup的构造方法中调用了<code>initViewGroup()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewGroup</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line"></span><br><span class="line">    initViewGroup();</span><br><span class="line">    initFromAttributes(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着来看<code>initViewGroup()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initViewGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ViewGroup doesn't draw by default</span></span><br><span class="line">    <span class="keyword">if</span> (!debugDraw()) &#123;</span><br><span class="line">        setFlags(WILL_NOT_DRAW, DRAW_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从注释<strong>ViewGroup doesn’t draw by default</strong>中也能看出ViewGroup默认情况下的确不会调用<code>draw()</code>方法，在<code>initViewGroup()</code>方法内部执行了<code>setFlags(WILL_NOT_DRAW, DRAW_MASK)</code>，从方法名可以看出是设置了一个标志位，我们接下来看一下<code>setFlags()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFlags</span><span class="params">(<span class="keyword">int</span> flags, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">int</span> old = mViewFlags;</span><br><span class="line">    <span class="comment">// 设置标志位</span></span><br><span class="line">    mViewFlags = (mViewFlags &amp; ~mask) | (flags &amp; mask);</span><br><span class="line">    <span class="comment">// 判断标志位是否改变</span></span><br><span class="line">    <span class="keyword">int</span> changed = mViewFlags ^ old;</span><br><span class="line">    <span class="keyword">if</span> (changed == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> privateFlags = mPrivateFlags;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> ((changed &amp; DRAW_MASK) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置了DRAW_MASK模式的标志位</span></span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; WILL_NOT_DRAW) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置了WILL_NOT_DRAW标志位</span></span><br><span class="line">            <span class="keyword">if</span> (mBackground != <span class="keyword">null</span></span><br><span class="line">                    || mDefaultFocusHighlight != <span class="keyword">null</span></span><br><span class="line">                    || (mForegroundInfo != <span class="keyword">null</span> &amp;&amp; mForegroundInfo.mDrawable != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="comment">// 如果设置了背景、焦点高亮背景或者前景，就移除PFLAG_SKIP_DRAW标志位</span></span><br><span class="line">                mPrivateFlags &amp;= ~PFLAG_SKIP_DRAW;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有设置背景、焦点高亮背景或者前景，就设置PFLAG_SKIP_DRAW标志位</span></span><br><span class="line">                mPrivateFlags |= PFLAG_SKIP_DRAW;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有设置WILL_NOT_DRAW标志位，移除PFLAG_SKIP_DRAW标志位</span></span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_SKIP_DRAW;</span><br><span class="line">        &#125;</span><br><span class="line">        requestLayout();</span><br><span class="line">        invalidate(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>setFlags()</code>方法有两个参数：flags和mask，flags就是要设置的标志位，mask表示标志位的位置，mPrivateFlags和mask进行按位与运算可以得到该mask对应的标志位，举个例子，执行了<code>setFlags(WILL_NOT_DRAW, DRAW_MASK)</code>后，通过<code>mPrivateFlags &amp; DRAW_MASK</code>就可以得到<strong>WILL_NOT_DRAW</strong>这个标志位。这里省略了大量代码，只保留了和<strong>DRAW_MASK</strong>相关的部分，其实View的可见状态VISIBLE、INVISIBLE和GONE也是通过标志位来实现的，感兴趣的话可以看一看。可以看出，当View设置了<strong>WILL_NOT_DRAW</strong>标志位，并且没有设置背景、焦点高亮背景或者前景（后面统称为背景）的情况下，会设置<strong>PFLAG_SKIP_DRAW</strong>标志位，由于ViewGroup默认情况下是没有设置背景的，因此会设置<strong>PFLAG_SKIP_DRAW</strong>标志位，不会执行<code>draw()</code>方法，当然也不会执行<code>onDraw()</code>方法。<br>如果想让ViewGroup的<code>draw()</code>方法被执行要怎么做呢？从上面的分析中也能看出，只要ViewGroup移除了<strong>WILL_NOT_DRAW</strong>标志位或者设置了背景，就会移除<strong>PFLAG_SKIP_DRAW</strong>标志位，使得<code>draw()</code>方法被调用，下面我们就看一下具体该怎么做。</p>
<ul>
<li>移除<strong>WILL_NOT_DRAW</strong>标志位</li>
</ul>
<p>View中有一个<code>setWillNotDraw()</code>方法，我们来看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWillNotDraw</span><span class="params">(<span class="keyword">boolean</span> willNotDraw)</span> </span>&#123;</span><br><span class="line">    setFlags(willNotDraw ? WILL_NOT_DRAW : <span class="number">0</span>, DRAW_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>setWillNotDraw()</code>方法内部会根据传入的willNotDraw参数调用<code>setFlags()</code>方法来设置或移除<strong>WILL_NOT_DRAW</strong>标志位，通过调用<code>setWillNotDraw(false)</code> 就可以移除<strong>WILL_NOT_DRAW</strong>标志位，使得ViewGroup的<code>draw()</code>方法得到调用。</p>
<ul>
<li>为ViewGroup设置背景（包括背景、焦点高亮背景和前景）</li>
</ul>
<p>这里就以设置背景的<code>setBackgroundDrawable()</code>方法为例分析，设置焦点高亮背景（对应<code>setDefaultFocusHighlight()</code>方法）和设置前景（对应<code>setForeground()</code>方法）类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBackgroundDrawable</span><span class="params">(Drawable background)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (background != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      	<span class="comment">// 设置背景，移除PFLAG_SKIP_DRAW标志位</span></span><br><span class="line">        <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) != <span class="number">0</span>) &#123;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_SKIP_DRAW;</span><br><span class="line">            requestLayout = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mBackground = <span class="keyword">null</span>;</span><br><span class="line">      	<span class="comment">// 取消背景，设置PFLAG_SKIP_DRAW标志位</span></span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; WILL_NOT_DRAW) != <span class="number">0</span></span><br><span class="line">                &amp;&amp; (mDefaultFocusHighlight == <span class="keyword">null</span>)</span><br><span class="line">                &amp;&amp; (mForegroundInfo == <span class="keyword">null</span> || mForegroundInfo.mDrawable == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            mPrivateFlags |= PFLAG_SKIP_DRAW;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当设置了背景后，mPrivateFlags会移除<strong>PFLAG_SKIP_DRAW</strong>标志位，因此可以通过设置背景的方式来使得ViewGroup的<code>draw()</code>方法得到执行。<br>通过以上两种方式就可以调用的ViewGroup的<code>draw()</code>方法了，从而使得<code>onDraw()</code>方法也会被调用。在开发中我们还是要考虑实际需求，因为ViewGroup本身只是一个容器，一般情况下是不需要绘制自身内容的，默认情况设置了<strong>PFLAG_SKIP_DRAW</strong>标志位也是出于系统优化的考虑，如果需要在<code>onDraw()</code>中绘制内容时再通过以上两种方式移除<strong>PFLAG_SKIP_DRAW</strong>标志位，或是直接在<code>dispatchDraw()</code>方法中进行绘制都可以。</p>
<h2 id="开发中的常见问题"><a href="#开发中的常见问题" class="headerlink" title="开发中的常见问题"></a>开发中的常见问题</h2><h3 id="View获取宽高"><a href="#View获取宽高" class="headerlink" title="View获取宽高"></a>View获取宽高</h3><p>根据此前的分析，View的三大流程都是在<code>onResume()</code>方法调用之后才开始的，因此在<code>onCreate()</code>、<code>onStart()</code>和<code>onResume()</code>方法中是无法通过<code>getWidth()</code>/<code>getHeight()</code>获取到View的宽高的。如果在开发中有这样的需求应该怎么办呢，当然还是有办法的，下面就介绍几种通过代码获取View宽高的方法。</p>
<ul>
<li>在<code>onWindowFocusChanged()</code>方法中获取</li>
</ul>
<p>重写Activity的<code>onWindowFocusChanged()</code>方法，在方法内部可以获取到View的宽高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onWindowFocusChanged(hasFocus);</span><br><span class="line">    <span class="keyword">if</span> (hasFocus) &#123;</span><br><span class="line">        <span class="keyword">int</span> width = view.getWidth();</span><br><span class="line">        <span class="keyword">int</span> height = view.getHeight();</span><br><span class="line">        Log.e(<span class="string">"TAG"</span>, <span class="string">"view的宽度为："</span> + width + <span class="string">",高度为："</span> + height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意，该方法在Activity获得和失去焦点时都会被调用，因此会被调用多次，不推荐采用这种方法获取View的宽高。</p>
<ul>
<li>使用ViewTreeObserver监听事件</li>
</ul>
<p><strong>ViewTreeObserver</strong>中定义了多种监听事件，可以通过设置<strong>OnGlobalLayoutListener</strong>（当View树的状态发生改变或者View树内部的View的可见状态发生改变时会回调<code>onGlobalLayout()</code>方法）和<strong>OnPreDrawListener</strong>（当View树被绘制之前会回调<code>onPreDraw()</code>方法）监听，在回调方法中获取View的宽高。需要注意，回调方法可能会被执行多次，因此在获取到View的宽高后需要移除监听器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ViewTreeObserver observer = view.getViewTreeObserver();</span><br><span class="line">observer.addOnGlobalLayoutListener(<span class="keyword">new</span> ViewTreeObserver.OnGlobalLayoutListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        view.getViewTreeObserver().removeOnGlobalLayoutListener(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">int</span> width = view.getWidth();</span><br><span class="line">        <span class="keyword">int</span> height = view.getHeight();</span><br><span class="line">        Log.e(<span class="string">"TAG"</span>, <span class="string">"view的宽度为："</span> + width + <span class="string">",高度为："</span> + height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">observer.addOnPreDrawListener(<span class="keyword">new</span> ViewTreeObserver.OnPreDrawListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onPreDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        view.getViewTreeObserver().removeOnPreDrawListener(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">int</span> width = view.getWidth();</span><br><span class="line">        <span class="keyword">int</span> height = view.getHeight();</span><br><span class="line">        Log.e(<span class="string">"TAG"</span>, <span class="string">"view的宽度为："</span> + width + <span class="string">",高度为："</span> + height);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用View的<code>post()</code>方法</li>
</ul>
<p>这个方法可以说是我们最熟悉的了，调用View的<code>post()</code>方法，传入一个Runnable对象，在<code>run()</code>方法中获取View的宽高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">view.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> width = view.getWidth();</span><br><span class="line">        <span class="keyword">int</span> height = view.getHeight();</span><br><span class="line">        Log.e(<span class="string">"TAG"</span>, <span class="string">"view的宽度为："</span> + width + <span class="string">",高度为："</span> + height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>简单解释一下原理，其实<code>post()</code>方法内部是通过Handler来实现的，调用<code>post()</code>方法后会将Runnable封装成一个同步消息添加到主线程的消息队列中，由于ViewRootImpl的<code>scheduleTraversals()</code>方法内部通过开启同步屏障机制发送了一条异步消息进行View树的measure、layout和draw，因此保证了View树的三大流程执行完成后再执行消息队列中的同步消息，此时当然就可以获取到View的宽高了。</p>
<h3 id="invalidate-和requestLayout-的区别"><a href="#invalidate-和requestLayout-的区别" class="headerlink" title="invalidate()和requestLayout()的区别"></a>invalidate()和requestLayout()的区别</h3><p>我们在自定义View时可能需要更新View的显示，比如为View添加动画等等，有两个方法是我们经常会用到的<code>invalidate()</code>和<code>requestLayout()</code>，下面就来具体分析一下这两个方法的区别和使用场景。</p>
<h4 id="invalidate"><a href="#invalidate" class="headerlink" title="invalidate()"></a>invalidate()</h4><p><strong>View的invalidate方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    invalidate(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(<span class="keyword">boolean</span> invalidateCache)</span> </span>&#123;</span><br><span class="line">    invalidateInternal(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop, invalidateCache, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出View的<code>invalidate()</code>方法最终会调用<code>invalidateInternal()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalidateInternal</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b, <span class="keyword">boolean</span> invalidateCache,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">boolean</span> fullInvalidate)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  	<span class="comment">// 判断是否跳过重绘</span></span><br><span class="line">    <span class="keyword">if</span> (skipInvalidate()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  	<span class="comment">// 判断是否需要重绘</span></span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)</span><br><span class="line">            || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)</span><br><span class="line">            || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED</span><br><span class="line">            || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fullInvalidate) &#123;</span><br><span class="line">            mLastIsOpaque = isOpaque();</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_DRAWN;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags |= PFLAG_DIRTY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (invalidateCache) &#123;</span><br><span class="line">            <span class="comment">// 设置PFLAG_INVALIDATED标志位</span></span><br><span class="line">            mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line">          	<span class="comment">// 移除PFLAG_DRAWING_CACHE_VALID标志位</span></span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> AttachInfo ai = mAttachInfo;</span><br><span class="line">        <span class="keyword">final</span> ViewParent p = mParent;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; ai != <span class="keyword">null</span> &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</span><br><span class="line">            <span class="comment">// damage表示要重绘的区域</span></span><br><span class="line">            <span class="keyword">final</span> Rect damage = ai.mTmpInvalRect;</span><br><span class="line">            damage.set(l, t, r, b);</span><br><span class="line">            <span class="comment">// 将要重绘的区域传给父View</span></span><br><span class="line">            p.invalidateChild(<span class="keyword">this</span>, damage);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invalidateInternal()</code>方法中首先会根据<code>skipInvalidate()</code>方法判断是否跳过绘制，如果同时满足以下三个条件就直接return，跳过重绘。</p>
<ul>
<li>View是不可见的</li>
<li>当前没有设置动画</li>
<li>父View的类型不是ViewGroup或者父ViewGoup不处于过渡态</li>
</ul>
<p>接下来根据一系列条件判断是否需要重绘，如果满足以下任意一条就进行重绘。</p>
<ul>
<li>View已经被绘制完成并且具有边界</li>
<li>invalidateCache为true并且设置了<strong>PFLAG_DRAWING_CACHE_VALID</strong>标志位，即绘制缓存可用</li>
<li>没有设置<strong>PFLAG_INVALIDATED</strong>标志位，即没有被重绘过</li>
<li>fullInvalidate为true并且透明度发生了变化</li>
</ul>
<p>接下来判断如果invalidateCache为true，就给View设置<strong>PFLAG_INVALIDATED</strong>标志位，这一步很重要，后面还会提到，通过上面的调用也能看出这里的invalidateCache传入的值为true，因此会设置这个标志位。方法的最后会调用mParent即父View的<code>invalidateChild()</code>方法，将要重绘的区域damage传递给父View。下面我们来看ViewGroup的<code>invalidateChild()</code>方法：<br><strong>ViewGroup的invalidateChild方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invalidateChild</span><span class="params">(View child, <span class="keyword">final</span> Rect dirty)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span> &amp;&amp; attachInfo.mHardwareAccelerated) &#123;</span><br><span class="line">      	<span class="comment">// 开启了硬件加速</span></span><br><span class="line">        onDescendantInvalidated(child, child);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ViewParent parent = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            View view = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">                view = (View) parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            parent = parent.invalidateChildInParent(location, dirty);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (parent != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法内部首先会判断是否开启了硬件加速，接下来我们分别看一下关闭和开启硬件加速情况下的重绘流程。</p>
<ul>
<li><strong>关闭硬件加速</strong></li>
</ul>
<p>关闭硬件加速的情况下会循环调用<code>invalidateChildInParent()</code>方法，将返回值赋给parent，当parent为null时退出循环，我们来看ViewGroup的<code>invalidateChildInParent()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewParent <span class="title">invalidateChildInParent</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span>[] location, <span class="keyword">final</span> Rect dirty)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      	<span class="comment">// 移除PFLAG_DRAWING_CACHE_VALID标志位</span></span><br><span class="line">      	mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">      	<span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> mParent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里省略了大量代码，主要是对子View传递过来的重绘区域进行运算处理，方法最后会返回mParent。因此在<code>invalidateChild()</code>方法中会通过循环逐层调用父View的<code>invalidateChildInParent()</code>方法，那么当调用到最顶层ViewGroup——DecorView的<code>invalidateChild()</code>方法时，它的mParent是谁呢？我们可以回顾一下ViewRootImpl的<code>setView()</code>方法：<br><strong>ViewRootImpl的setView方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mView = view;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            requestLayout();</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            view.assignParent(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现方法执行了<code>view.assignParent(this)</code>，这里的view其实就是DecorView（ActivityThread的<code>handleResumeActivity()</code>方法中调用<code>wm.addView()</code>传过来的），我们来看一下<code>assignParent()</code>方法，它定义在View中：<br><strong>View的assignParent方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assignParent</span><span class="params">(ViewParent parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mParent = parent;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mParent = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"view "</span> + <span class="keyword">this</span> + <span class="string">" being added, but"</span></span><br><span class="line">                + <span class="string">" it already has a parent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显<code>assignParent()</code>方法完成了View的成员变量mParent的赋值，因此DecorView的mParent就是上面传入的this，也就是ViewRootImpl。既然清楚了DecorView的mParent，接下来我们就来看一下ViewRootImpl的<code>invalidateChildInParent()</code>方法：<br><strong>ViewRootImpl的invalidateChildInParent方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewParent <span class="title">invalidateChildInParent</span><span class="params">(<span class="keyword">int</span>[] location, Rect dirty)</span> </span>&#123;</span><br><span class="line">    checkThread();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    invalidateRectOnScreen(dirty);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法内部首先会调用<code>checkThread()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(</span><br><span class="line">                <span class="string">"Only the original thread that created a view hierarchy can touch its views."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>checkThread()</code>方法会判断当前线程是否为主线程，如果不是主线程就直接抛出异常，因此我们需要特别注意，<strong><code>invalidate()</code>方法必须在主线程中调用</strong>。回到ViewRootImpl的<code>invalidateChildInParent()</code>方法，最后调用了<code>invalidateRectOnScreen()</code>方法，同时由于返回值为null，因此执行完<code>invalidateChildInParent()</code>方法后parent被赋值为null，退出do-while循环。接下来我们就来看一下<code>invalidateRectOnScreen()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invalidateRectOnScreen</span><span class="params">(Rect dirty)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invalidateRectOnScreen()</code>方法内部会调用<code>scheduleTraversals()</code>方法，这个方法我们很熟悉了，接下来会调用<code>performTraversals()</code>方法，开始View的三大流程，这里再来回顾一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">boolean</span> layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">    <span class="keyword">if</span> (layoutRequested) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 调用performMeasure()方法开始measure流程</span></span><br><span class="line">        measureHierarchy(host, lp, res,</span><br><span class="line">                desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">    <span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 开始layout流程</span></span><br><span class="line">        performLayout(lp, mWidth, mHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 开始draw流程</span></span><br><span class="line">    performDraw();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于此时没有给mLayoutRequested赋值，它的默认值为false，因此不会调用<code>measureHierarchy()</code>和<code>performLayout()</code>方法，只调用<code>performDraw()</code>方法，换句话说就是不会执行measure和layout流程，只执行draw流程，接下来就是调用DecorView的<code>draw()</code>方法，遍历DecorView的子View，逐层完成子View的绘制。</p>
<ul>
<li><strong>开启硬件加速</strong></li>
</ul>
<p>开启硬件加速时在ViewGroup的<code>invalidateChild()</code>方法中会调用<code>onDescendantInvalidated()</code>方法并直接返回，不会执行后面的<code>invalidateChildInParent()</code>方法，我们来看一下<code>onDescendantInvalidated()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDescendantInvalidated</span><span class="params">(@NonNull View child, @NonNull View target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mParent.onDescendantInvalidated(<span class="keyword">this</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法内部会调用mParent的<code>onDescendantInvalidated()</code>方法，和<code>invalidateChildInParent()</code>类似，接下来会逐级调用父View的<code>onDescendantInvalidated()</code>方法，最后来到ViewRootImpl的<code>onDescendantInvalidated()</code>方法。<br><strong>ViewRootImpl的onDescendantInvalidated方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDescendantInvalidated</span><span class="params">(@NonNull View child, @NonNull View descendant)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((descendant.mPrivateFlags &amp; PFLAG_DRAW_ANIMATION) != <span class="number">0</span>) &#123;</span><br><span class="line">        mIsAnimating = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来会调用ViewRootImpl的<code>invalidate</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDirty.set(<span class="number">0</span>, <span class="number">0</span>, mWidth, mHeight);</span><br><span class="line">    <span class="keyword">if</span> (!mWillDrawSoon) &#123;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里同样调用了<code>scheduleTraversals()</code>方法，之后的流程和关闭硬件加速的情况类似，同样是调用<code>performDraw()</code>方法，不同的是开启硬件加速的情况下会执行<code>mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, this, callback)</code>，前面也分析过了，之后会依次调用ThreadedRenderer的<code>updateRootDisplayList()</code>、<code>updateViewTreeDisplayList()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateViewTreeDisplayList</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    view.mPrivateFlags |= View.PFLAG_DRAWN;</span><br><span class="line">    view.mRecreateDisplayList = (view.mPrivateFlags &amp; View.PFLAG_INVALIDATED)</span><br><span class="line">            == View.PFLAG_INVALIDATED;</span><br><span class="line">    view.mPrivateFlags &amp;= ~View.PFLAG_INVALIDATED;</span><br><span class="line">    view.updateDisplayListIfDirty();</span><br><span class="line">    view.mRecreateDisplayList = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意，根据此前的分析，在调用View的<code>invalidate()</code>方法后，会给当前View设置<strong>PFLAG_INVALIDATED</strong>标志位，因此它的mRecreateDisplayList变量值为true，而其他的父级View由于没有设置<strong>PFLAG_INVALIDATED</strong>标志位，mRecreateDisplayList值为false。接下来会调用view的<code>updateDisplayListIfDirty()</code>方法，这里的view是DecorView。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RenderNode <span class="title">updateDisplayListIfDirty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RenderNode renderNode = mRenderNode;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == <span class="number">0</span></span><br><span class="line">            || !renderNode.isValid()</span><br><span class="line">            || (mRecreateDisplayList)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (renderNode.isValid()</span><br><span class="line">                &amp;&amp; !mRecreateDisplayList) &#123;</span><br><span class="line">            <span class="comment">// 不需要重新进行绘制</span></span><br><span class="line">            mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">            dispatchGetDisplayList();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> renderNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要重新进行绘制</span></span><br><span class="line">        mRecreateDisplayList = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</span><br><span class="line">              	<span class="comment">// 如果设置了PFLAG_SKIP_DRAW标志位，执行dispatchDraw()方法</span></span><br><span class="line">                dispatchDraw(canvas);</span><br><span class="line">                drawAutofilledHighlight(canvas);</span><br><span class="line">                <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">                    mOverlay.getOverlayView().draw(canvas);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (debugDraw()) &#123;</span><br><span class="line">                    debugDrawFocus(canvas);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             	<span class="comment">// 没有设置PFLAG_SKIP_DRAW标志位，执行draw()方法</span></span><br><span class="line">                draw(canvas);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            renderNode.end(canvas);</span><br><span class="line">            setDisplayListProperties(renderNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> renderNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就和此前的分析不同了，由于页面首次绘制完成后执行了<code>renderNode.end(canvas)</code>，因此这里<code>renderNode.isValid()</code>返回值为true，而DecorView的mRecreateDisplayList值为false，因不会执行后面的重新绘制逻辑，取而代之的是调用<code>dispatchGetDisplayList()</code>方法，我们来看一下这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchGetDisplayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = children[i];</span><br><span class="line">        <span class="keyword">if</span> (((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            recreateChildDisplayList(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recreateChildDisplayList</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">    child.mRecreateDisplayList = (child.mPrivateFlags &amp; PFLAG_INVALIDATED) != <span class="number">0</span>;</span><br><span class="line">    child.mPrivateFlags &amp;= ~PFLAG_INVALIDATED;</span><br><span class="line">    child.updateDisplayListIfDirty();</span><br><span class="line">    child.mRecreateDisplayList = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dispatchGetDisplayList()</code>方法内部会遍历子View，依次调用<code>recreateChildDisplayList()</code>方法，不难看出<code>recreateChildDisplayList()</code>方法和<code>updateViewTreeDisplayList()</code>方法很像，接下来同样会调用<code>updateDisplayListIfDirty()</code>方法，对于没有设置<strong>PFLAG_INVALIDATED</strong>标志位的View，它的mRecreateDisplayList值为false，会重复上面的过程，即调用<code>dispatchGetDisplayList()</code>方法；而对于调用了<code>invalidate()</code>方法的View，由于设置了<strong>PFLAG_INVALIDATED</strong>标志位，它的mRecreateDisplayList值为true，会执行<code>updateDisplayListIfDirty()</code>方法最后的重绘逻辑，即调用<code>dispatchDraw()</code>方法或者<code>draw()</code>方法完成自身及子View的绘制。<br>最后总结一下<code>invalidate()</code>方法，调用View的<code>invalidate()</code>方法后会逐级调用父View的方法，最终导致ViewRootImpl的<code>scheduleTraversals()</code>方法被调用，进而调用<code>performTraversals()</code>方法。由于mLayoutRequested的值为false，因此不会执行measure和layout流程，只执行draw流程。draw流程的执行过程和是否开启硬件加速有关：</p>
<ul>
<li>如果关闭了硬件加速，从DecorView开始的所有View都会重新完成绘制</li>
<li>如果开启了硬件加速，只有调用<code>invalidate()</code>方法的View（包括它的子View）会完成重新绘制</li>
</ul>
<p>由此也可以看出，开启硬件加速确实可以提高重绘的效率。<br>此外，由于<code>invalidate()</code>方法必须在主线程中调用，那么如果我们想要在子线程中刷新视图要怎么做呢？不用担心，官方还为我们提供了一个<code>postInvalidate()</code>方法，其实从名称上我们也能猜到它的作用了，就是用于在子线程中刷新视图，简单看一下它的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postInvalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    postInvalidateDelayed(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postInvalidateDelayed</span><span class="params">(<span class="keyword">long</span> delayMilliseconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        attachInfo.mViewRootImpl.dispatchInvalidateDelayed(<span class="keyword">this</span>, delayMilliseconds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchInvalidateDelayed</span><span class="params">(View view, <span class="keyword">long</span> delayMilliseconds)</span> </span>&#123;</span><br><span class="line">    Message msg = mHandler.obtainMessage(MSG_INVALIDATE, view);</span><br><span class="line">    mHandler.sendMessageDelayed(msg, delayMilliseconds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哈哈，果然还是用到了Handler，mHandler是ViewRootImpl中的一个成员变量，类型为<strong>ViewRootHandler</strong>，我们来看一下ViewRootHandler对<strong>MSG_INVALIDATE</strong>消息的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_INVALIDATE:</span><br><span class="line">                ((View) msg.obj).invalidate();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出最后还是调用了<code>invalidate()</code>方法，因此<code>postInvalidate()</code>方法其实就是通过Handler完成了线程的切换，使得<code>invalidate()</code>方法在主线程中被调用。</p>
<h4 id="requestLayout"><a href="#requestLayout" class="headerlink" title="requestLayout()"></a>requestLayout()</h4><p><strong>View的requestLayout方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  	<span class="comment">// 给View添加两个标志位</span></span><br><span class="line">    mPrivateFlags |= PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class="line">      	<span class="comment">// 调用父类的requestLayout()方法</span></span><br><span class="line">        mParent.requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>requestLayout()</code>方法内部会调用mParent即父View的<code>requestLayout()</code>方法，最终会来到ViewRootImpl的<code>requestLayout()</code>方法：<br><strong>ViewRootImpl的requestLayout方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先还是会进行线程的检查，因此<code>requestLayout()</code>方法同样只能在主线程中调用。接着会把mLayoutRequested赋值为true并调用<code>scheduleTraversals()</code>方法。后面的流程相信也不用我多说了，调用<code>performTraversals()</code>方法，由于将mLayoutRequested赋值为true，因此会依次执行<code>measureHierarchy()</code>、<code>performLayout()</code>和<code>performDraw()</code>方法，开始View的三大流程。<br>到这里还没完，我们需要探究一下View调用<code>requrestLayout()</code>是否会导致View树中的所有View都进行重新测量、布局和绘制。我们注意到调用<code>requestLayout()</code>方法后，会为当前View及所有父级View添加<strong>PFLAG_FORCE_LAYOUT</strong>和<strong>PFLAG_INVALIDATED</strong>标志位。首先来回顾一下View的<code>measure()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> specChanged = widthMeasureSpec != mOldWidthMeasureSpec</span><br><span class="line">            || heightMeasureSpec != mOldHeightMeasureSpec;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY</span><br><span class="line">            &amp;&amp; MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> matchesSpecSize = getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec)</span><br><span class="line">            &amp;&amp; getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> needsLayout = specChanged</span><br><span class="line">            &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (forceLayout || needsLayout) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      	<span class="comment">// 设置PFLAG_LAYOUT_REQUIRED标志位</span></span><br><span class="line">        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOldWidthMeasureSpec = widthMeasureSpec;</span><br><span class="line">    mOldHeightMeasureSpec = heightMeasureSpec;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，当View设置了<strong>PFLAG_FORCE_LAYOUT</strong>标志位后，forceLayout的值为true，因此会执行<code>onMeasure()</code> 方法，而对于没有设置<strong>PFLAG_FORCE_LAYOUT</strong>标志位的View，需要判断测量尺寸是否发生了改变，如果改变了才会调用<code>onMeasure()</code>方法。在调用<code>onMeasure()</code>方法后会给View设置<strong>PFLAG_LAYOUT_REQUIRED</strong>标志位，我们再来看View的<code>layout()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">int</span> oldL = mLeft;</span><br><span class="line">    <span class="keyword">int</span> oldT = mTop;</span><br><span class="line">    <span class="keyword">int</span> oldB = mBottom;</span><br><span class="line">    <span class="keyword">int</span> oldR = mRight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于设置了<strong>PFLAG_LAYOUT_REQUIRED</strong>标志位的View，<code>onLayout()</code>方法肯定会执行，另一种情况就是View的四个顶点坐标发生改变，也会执行<code>onLayout()</code>方法。<br>结合上面的分析可以得出结论，当View调用了<code>requestLayout()</code>方法后，自身及父级View的<code>onMeasure()</code>和<code>onLayout()</code>方法会被调用，对于它的子View，<code>onMeasure()</code>和<code>onLayout()</code>方法不一定被调用。<br>对于draw流程，前面分析过<code>performDraw()</code>方法会调用ViewRootImpl中的<code>draw()</code>方法：<br><strong>ViewRootImpl的draw方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  	<span class="keyword">final</span> Rect dirty = mDirty;</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// 开启了硬件加速</span></span><br><span class="line">            mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class="keyword">this</span>, callback);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// 关闭了硬件加速</span></span><br><span class="line">            <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset,</span><br><span class="line">                    scalingRequired, dirty, surfaceInsets)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> useAsyncReport;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dirty指向ViewRootImpl中的一个成员变量mDirty，类型为Rect，在ViewRootImpl的<code>invalidate()</code>方法中会调用<code>set()</code>方法为其设置四个边界值，由于此时没有调用<code>invalidate()</code>方法，因此<code>mDirty.isEmpty()</code>返回true，不会执行后面的绘制方法，因此整个View树不会进行重新绘制。不过也有这样一种情况，我们知道在执行VIew的layout流程时会调用<code>setFrame()</code>方法，在<code>setFrame()</code>方法中有这样的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> oldWidth = mRight - mLeft;</span><br><span class="line"><span class="keyword">int</span> oldHeight = mBottom - mTop;</span><br><span class="line"><span class="keyword">int</span> newWidth = right - left;</span><br><span class="line"><span class="keyword">int</span> newHeight = bottom - top;</span><br><span class="line"><span class="keyword">boolean</span> sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);</span><br><span class="line"></span><br><span class="line">invalidate(sizeChanged);</span><br></pre></td></tr></table></figure>

<p>可以看出当View的宽或高发生改变时会调用<code>invalidate()</code>方法，导致View的重新绘制。<br>最后总结一下<code>invalidate()</code>和<code>requestLayout()</code>的异同：<br><strong>相同点</strong><br>1.<code>invalidate()</code>和<code>requestLayout()</code>方法最终都会调用ViewRootImpl的<code>performTraversals()</code>方法。<br><strong>不同点</strong><br>1.<code>invalidate()</code>方法不会执行<code>measureHierarchy()</code>和<code>performLayout()</code>方法，也就不会执行measure和layout流程，只执行draw流程，如果开启了硬件加速则只进行调用者View的重绘。<br>2.<code>requestLayout()</code>方法会依次<code>measureHierarchy()</code>、<code>performLayout()</code>和<code>performDraw()</code>方法，调用者View和它的父级View会重新进行measure、layout，一般情况下不会执行draw流程，子View不一定会重新measure和layout。<br>综上，当只需要进行重新绘制时就调用<code>invalidate()</code>，如果需要重新测量和布局就调用<code>requestLayout()</code>，但是<code>requestLayout()</code>不保证进行重新绘制，如果要进行重新绘制可以再手动调用<code>invalidate()</code>。<br>下面就以一个简单的例子验证一下上面的几个结论，我定义了两个ViewGroup和一个View，代码很简单，如下所示：<br><strong>MyViewGroup1.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewGroup1</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyViewGroup1</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyViewGroup1</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyViewGroup1</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        setWillNotDraw(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        Log.e(<span class="string">"TAG"</span>, <span class="string">"MyViewGroup1执行了onMeasure"</span>);</span><br><span class="line">        measureChildren(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">"TAG"</span>, <span class="string">"MyViewGroup1执行了onLayout"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getChildCount(); i++) &#123;</span><br><span class="line">            View child = getChildAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> width = child.getMeasuredWidth();</span><br><span class="line">            <span class="keyword">int</span> height = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">            child.layout(l, t, l + width, t + height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        Log.e(<span class="string">"TAG"</span>, <span class="string">"MyViewGroup1执行了onDraw"</span>);</span><br><span class="line">        canvas.drawColor(Color.YELLOW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MyViewGroup2.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewGroup2</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyViewGroup2</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyViewGroup2</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyViewGroup2</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        setWillNotDraw(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        Log.e(<span class="string">"TAG"</span>, <span class="string">"MyViewGroup2执行了onMeasure"</span>);</span><br><span class="line">        measureChildren(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">"TAG"</span>, <span class="string">"MyViewGroup2执行了onLayout"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getChildCount(); i++) &#123;</span><br><span class="line">            View child = getChildAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> width = child.getMeasuredWidth();</span><br><span class="line">            <span class="keyword">int</span> height = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">            child.layout(l, t, l + width, t + height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        Log.e(<span class="string">"TAG"</span>, <span class="string">"MyViewGroup2执行了onDraw"</span>);</span><br><span class="line">        canvas.drawColor(Color.GREEN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MyView.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        Log.e(<span class="string">"TAG"</span>, <span class="string">"MyView执行了onMeasure"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onLayout(changed, left, top, right, bottom);</span><br><span class="line">        Log.e(<span class="string">"TAG"</span>, <span class="string">"MyView执行了onLayout"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        Log.e(<span class="string">"TAG"</span>, <span class="string">"MyView执行了onDraw"</span>);</span><br><span class="line">        canvas.drawColor(Color.RED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了保证ViewGroup的<code>onDraw()</code>方法执行，我在构造方法中调用了<code>setWillNotDraw(false)</code>。布局文件也很简单，一个三级的嵌套：<br><strong>activity_test.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">com.example.MyViewGroup1</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/myViewGroup1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.example.MyViewGroup2</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/myViewGroup2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"300dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"300dp"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.example.MyView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/myView"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"200dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"200dp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">com.example.MyViewGroup2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">com.example.MyViewGroup1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行后的效果如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS1jY2NkMWQ5MzlkNzAzYzBhLmpwZw?x-oss-process=image/format,png" alt><br>我给三个View添加了点击事件，点击后分别调用自身的<code>invalidate()</code>或<code>requestLayout()</code>方法，下面分情况看一下。</p>
<ul>
<li>调用<code>invalidate()</code>方法</li>
</ul>
<p><strong>开启硬件加速</strong><br>调用MyView的<code>invalidate()</code>方法：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS1iNmIxNWFiNGZjY2U1NmUyLnBuZw?x-oss-process=image/format,png" alt><br>调用MyViewGroup2的<code>invalidate()</code>方法：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS0yZDM1NDVmMjM3ZGYzNDIyLnBuZw?x-oss-process=image/format,png" alt><br>调用MyViewGroup1的<code>invalidate()</code>方法：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS1hNTBiY2E5ZmZiNjgzMTNiLnBuZw?x-oss-process=image/format,png" alt><br><strong>关闭硬件加速</strong><br>调用MyView的<code>invalidate()</code>方法：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS03YzMwN2YzMTIyMGZjMDNlLnBuZw?x-oss-process=image/format,png" alt><br>调用MyViewGroup2的<code>invalidate()</code>方法：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS03YzMwN2YzMTIyMGZjMDNlLnBuZw?x-oss-process=image/format,png" alt><br>调用MyViewGroup1的<code>invalidate()</code>方法：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS03YzMwN2YzMTIyMGZjMDNlLnBuZw?x-oss-process=image/format,png" alt><br>可以看出，关闭硬件加速时，调用任何一个View的<code>invalidate()</code>方法都会导致整个View树的重新绘制；开启硬件加速时，调用哪一个View的<code>invalidate()</code>方法就会重绘哪一个View。<code>invalidate()</code>方法不会导致<code>onMeasure()</code>和<code>onLayout()</code>被调用。</p>
<ul>
<li>调用<code>requestLayout()</code>方法</li>
</ul>
<p><strong>开启硬件加速</strong><br>调用MyView的<code>requestLayout()</code>方法：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS04YmFjNjJkODhhMzIzOGQ1LnBuZw?x-oss-process=image/format,png" alt><br>调用MyViewGroup2的<code>requestLayout()</code>方法：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS05YzQyM2YwNzc5MTMwODQ3LnBuZw?x-oss-process=image/format,png" alt><br>调用MyViewGroup1的<code>requestLayout()</code>方法：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS05ODZlZjA0Njc0MmU0ZWNlLnBuZw?x-oss-process=image/format,png" alt><br><strong>关闭硬件加速</strong><br>调用MyView的<code>requestLayout()</code>方法：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS04YmFjNjJkODhhMzIzOGQ1LnBuZw?x-oss-process=image/format,png" alt><br>调用MyViewGroup2的<code>requestLayout()</code>方法：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS05YzQyM2YwNzc5MTMwODQ3LnBuZw?x-oss-process=image/format,png" alt><br>调用MyViewGroup1的<code>requestLayout()</code>方法：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjE2OTA4OS05ODZlZjA0Njc0MmU0ZWNlLnBuZw?x-oss-process=image/format,png" alt><br>可以看出此时是否开启硬件加速对于<code>requestLayout()</code>方法的调用流程没有影响，调用View的<code>requestLayout()</code>方法会导致自身及其父View的<code>onMeasure()</code>和<code>onLayout()</code>方法被调用，并不会调用<code>onDraw()</code>方法进行重绘，当然前面也分析过了，<code>onDraw()</code>方法不是一定不会被调用，当View重新绘制时硬件加速的作用就会有所体现了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章其实算是知识点总结，篇幅很长，很多地方我都想尽可能涵盖多一些知识点而不是直接一笔带过，前前后后整理了差不多一个月时间吧，期间阅读了很多优秀的文章，对于我自己来说收获还是很大的，让我更加系统地认识了View的工作原理，源码的阅读能力也有了一定的提升。自定义View这块对于我来说一直是一块难啃的骨头，了解View的工作原理算是打好了坚实的基础，纸上得来终觉浅，绝知此事要躬行，想要真正要提高自己的自定义View水平还是要亲自写几个实例来练习。<br>由于自身水平的原因，对于文章中分析得不正确的地方，欢迎大家交流指出。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>《Android开发艺术探索》<br><a href="https://www.jianshu.com/p/e79a55c141d6" target="_blank" rel="noopener">Android：一篇文章带你完全梳理自定义View工作流程！</a><br><a href="https://blog.csdn.net/xfhy_/article/details/90270630" target="_blank" rel="noopener">死磕Android_View工作原理你需要知道的一切</a><br><a href="https://juejin.im/post/5d53ddd6f265da03d15549b8" target="_blank" rel="noopener">invalidate、postInvalidate与requestLayout浅析</a></p>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/Android/" rel="tag"><i class="fa fa-tag"></i> Android</a>
            
              <a href="/tags/View/" rel="tag"><i class="fa fa-tag"></i> View</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/08/26/App启动流程分析/" rel="next" title="App启动流程分析">
                  <i class="fa fa-chevron-left"></i> App启动流程分析
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc" data-target="post-toc-wrap">
          文章目录
        </li>
        <li class="sidebar-nav-overview" data-target="site-overview-wrap">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc">
            <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#几个相关类"><span class="nav-number">1.</span> <span class="nav-text">几个相关类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Window和WindowManager"><span class="nav-number">1.1.</span> <span class="nav-text">Window和WindowManager</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DecorView"><span class="nav-number">1.2.</span> <span class="nav-text">DecorView</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ViewRoot"><span class="nav-number">1.3.</span> <span class="nav-text">ViewRoot</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#准备阶段"><span class="nav-number">2.</span> <span class="nav-text">准备阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Window的创建"><span class="nav-number">2.1.</span> <span class="nav-text">Window的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DecorView的创建"><span class="nav-number">2.2.</span> <span class="nav-text">DecorView的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三大流程的调用"><span class="nav-number">2.3.</span> <span class="nav-text">三大流程的调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#measure阶段"><span class="nav-number">3.</span> <span class="nav-text">measure阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MeasureSpec"><span class="nav-number">3.1.</span> <span class="nav-text">MeasureSpec</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MeasureSpec简介"><span class="nav-number">3.1.1.</span> <span class="nav-text">MeasureSpec简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何确定MeasureSpec的值"><span class="nav-number">3.1.2.</span> <span class="nav-text">如何确定MeasureSpec的值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LayoutParams"><span class="nav-number">3.2.</span> <span class="nav-text">LayoutParams</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LayoutParams简介"><span class="nav-number">3.2.1.</span> <span class="nav-text">LayoutParams简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#View的LayoutParams属性是何时设置的"><span class="nav-number">3.2.2.</span> <span class="nav-text">View的LayoutParams属性是何时设置的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义LayoutParams须知"><span class="nav-number">3.2.3.</span> <span class="nav-text">自定义LayoutParams须知</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#measure流程"><span class="nav-number">3.3.</span> <span class="nav-text">measure流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单一View的measure流程"><span class="nav-number">3.3.1.</span> <span class="nav-text">单一View的measure流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ViewGroup的measure流程"><span class="nav-number">3.3.2.</span> <span class="nav-text">ViewGroup的measure流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#补充：MeasureSpec-UNSPECIFIED的应用"><span class="nav-number">3.4.</span> <span class="nav-text">补充：MeasureSpec.UNSPECIFIED的应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#layout阶段"><span class="nav-number">4.</span> <span class="nav-text">layout阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单一View的layout流程"><span class="nav-number">4.1.</span> <span class="nav-text">单一View的layout流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ViewGroup的layout流程"><span class="nav-number">4.2.</span> <span class="nav-text">ViewGroup的layout流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getMeasureWidth-getMeasureHeight和getWidth-getHeight的区别"><span class="nav-number">4.3.</span> <span class="nav-text">getMeasureWidth/getMeasureHeight和getWidth/getHeight的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#draw阶段"><span class="nav-number">5.</span> <span class="nav-text">draw阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单一View的draw流程"><span class="nav-number">5.1.</span> <span class="nav-text">单一View的draw流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ViewGroup的draw流程"><span class="nav-number">5.2.</span> <span class="nav-text">ViewGroup的draw流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ViewGroup的draw-方法调用问题"><span class="nav-number">5.3.</span> <span class="nav-text">ViewGroup的draw()方法调用问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开发中的常见问题"><span class="nav-number">6.</span> <span class="nav-text">开发中的常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#View获取宽高"><span class="nav-number">6.1.</span> <span class="nav-text">View获取宽高</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#invalidate-和requestLayout-的区别"><span class="nav-number">6.2.</span> <span class="nav-text">invalidate()和requestLayout()的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#invalidate"><span class="nav-number">6.2.1.</span> <span class="nav-text">invalidate()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#requestLayout"><span class="nav-number">6.2.2.</span> <span class="nav-text">requestLayout()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文章"><span class="nav-number">8.</span> <span class="nav-text">参考文章</span></a></li></ol></div>
          </div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/uploads/avatar.jpg"
      alt="Stephen Curry">
  <p class="site-author-name" itemprop="name">Stephen Curry</p>
  <div class="site-description motion-element" itemprop="description">I can do all things</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
        
        
          
        
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
        
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
        
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/StephenZKCurry" title="GitHub &rarr; https://github.com/StephenZKCurry" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
  </div>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Stephen Curry</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>












        
      </div>
    </footer>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  </div>

  
    
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>
<script src="/js/schemes/pisces.js?v=7.3.0"></script>

<script src="/js/next-boot.js?v=7.3.0"></script>



  








  <script src="/js/local-search.js?v=7.3.0"></script>














  

  

  


  
  <script src="/js/post-details.js?v=7.3.0"></script>


</body>
</html>
